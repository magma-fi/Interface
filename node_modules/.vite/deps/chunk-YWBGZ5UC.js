import {
  HDNode,
  Wallet,
  Wordlist,
  defaultPath,
  entropyToMnemonic,
  getAccountPath,
  getJsonWalletAddress,
  init_lib as init_lib22,
  init_lib2 as init_lib23,
  init_lib3 as init_lib24,
  init_lib4 as init_lib25,
  isValidMnemonic,
  mnemonicToEntropy,
  mnemonicToSeed,
  verifyMessage,
  verifyTypedData,
  wordlists
} from "./chunk-CMU2ARS3.js";
import {
  BaseContract,
  Contract,
  ContractFactory,
  init_lib as init_lib16
} from "./chunk-7F3IPCMU.js";
import {
  _fetchData,
  fetchJson,
  getDefaultProvider,
  init_lib as init_lib19,
  init_lib2 as init_lib21,
  lib_exports2 as lib_exports4,
  poll
} from "./chunk-5IOYYMYR.js";
import {
  Base58,
  SupportedAlgorithm,
  computeHmac,
  init_lib as init_lib17,
  init_lib2 as init_lib18,
  init_lib3 as init_lib20,
  randomBytes,
  ripemd160,
  sha256,
  sha512,
  shuffled
} from "./chunk-7IGKFX3U.js";
import {
  Signer,
  SigningKey,
  TransactionTypes,
  VoidSigner,
  accessListify,
  computeAddress,
  computePublicKey,
  init_lib as init_lib13,
  init_lib2 as init_lib14,
  init_lib3 as init_lib15,
  parse,
  recoverAddress,
  recoverPublicKey,
  serialize
} from "./chunk-T52DPOSF.js";
import {
  AbiCoder,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  Indexed,
  Interface,
  LogDescription,
  ParamType,
  TransactionDescription,
  checkResultErrors,
  defaultAbiCoder,
  init_lib as init_lib12
} from "./chunk-D4XBSYTF.js";
import {
  TypedDataEncoder,
  UnicodeNormalizationForm,
  Utf8ErrorFuncs,
  Utf8ErrorReason,
  _toEscapedUtf8String,
  dnsEncode,
  formatBytes32String,
  hashMessage,
  id,
  init_lib as init_lib9,
  init_lib2 as init_lib10,
  init_lib3 as init_lib11,
  isValidName,
  lib_exports2 as lib_exports3,
  namehash,
  nameprep,
  parseBytes32String,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String
} from "./chunk-OEYWMA6Q.js";
import {
  checkProperties,
  deepCopy,
  defineReadOnly,
  getStatic,
  init_lib as init_lib7,
  resolveProperties,
  shallowCopy
} from "./chunk-NX6UMJZK.js";
import {
  init_lib as init_lib8,
  lib_exports as lib_exports2
} from "./chunk-PPBSEKDQ.js";
import {
  getAddress,
  getContractAddress,
  getCreate2Address,
  getIcapAddress,
  init_lib as init_lib4,
  init_lib2 as init_lib5,
  init_lib3 as init_lib6,
  isAddress,
  keccak256,
  lib_exports2 as lib_exports
} from "./chunk-HWCAXKAJ.js";
import {
  BigNumber,
  FixedNumber,
  formatFixed,
  init_lib as init_lib3,
  parseFixed
} from "./chunk-WJIB2CDQ.js";
import {
  arrayify,
  concat,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  init_lib as init_lib2,
  isBytes,
  isBytesLike,
  isHexString,
  joinSignature,
  splitSignature,
  stripZeros,
  zeroPad
} from "./chunk-GMRHNXBP.js";
import {
  ErrorCode,
  Logger,
  init_lib
} from "./chunk-ILADNUF6.js";
import {
  __esm,
  __export
} from "./chunk-W7S2ME4R.js";

// ../../node_modules/@ethersproject/solidity/lib.esm/_version.js
var version;
var init_version = __esm({
  "../../node_modules/@ethersproject/solidity/lib.esm/_version.js"() {
    version = "solidity/5.7.0";
  }
});

// ../../node_modules/@ethersproject/solidity/lib.esm/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  keccak256: () => keccak2562,
  pack: () => pack,
  sha256: () => sha2562
});
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    if (count != value.length) {
      logger.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger.throwArgumentError("invalid type", "type", type);
}
function pack(types, values) {
  if (types.length != values.length) {
    logger.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak2562(types, values) {
  return keccak256(pack(types, values));
}
function sha2562(types, values) {
  return sha256(pack(types, values));
}
var regexBytes, regexNumber, regexArray, Zeros, logger;
var init_lib26 = __esm({
  "../../node_modules/@ethersproject/solidity/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib18();
    init_lib9();
    init_lib();
    init_version();
    regexBytes = new RegExp("^bytes([0-9]+)$");
    regexNumber = new RegExp("^(u?int)([0-9]*)$");
    regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
    logger = new Logger(version);
  }
});

// ../../node_modules/@ethersproject/units/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "../../node_modules/@ethersproject/units/lib.esm/_version.js"() {
    version2 = "units/5.7.0";
  }
});

// ../../node_modules/@ethersproject/units/lib.esm/index.js
var lib_exports6 = {};
__export(lib_exports6, {
  commify: () => commify,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  parseEther: () => parseEther,
  parseUnits: () => parseUnits
});
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger2.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger2.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var logger2, names;
var init_lib27 = __esm({
  "../../node_modules/@ethersproject/units/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib();
    init_version2();
    logger2 = new Logger(version2);
    names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
  }
});

// ../../node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports3,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  dnsEncode: () => dnsEncode,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});
var init_utils = __esm({
  "../../node_modules/ethers/lib.esm/utils.js"() {
    "use strict";
    init_lib12();
    init_lib6();
    init_lib10();
    init_lib17();
    init_lib2();
    init_lib11();
    init_lib23();
    init_lib24();
    init_lib4();
    init_lib();
    init_lib18();
    init_lib26();
    init_lib20();
    init_lib7();
    init_lib5();
    init_lib14();
    init_lib9();
    init_lib15();
    init_lib27();
    init_lib25();
    init_lib19();
    init_lib18();
    init_lib9();
  }
});

// ../../node_modules/ethers/lib.esm/_version.js
var version3;
var init_version3 = __esm({
  "../../node_modules/ethers/lib.esm/_version.js"() {
    version3 = "ethers/5.7.2";
  }
});

// ../../node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger3,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version3,
  wordlists: () => wordlists
});
var logger3;
var init_ethers = __esm({
  "../../node_modules/ethers/lib.esm/ethers.js"() {
    "use strict";
    init_lib16();
    init_lib3();
    init_lib13();
    init_lib25();
    init_lib8();
    init_lib21();
    init_lib21();
    init_lib22();
    init_utils();
    init_lib();
    init_version3();
    logger3 = new Logger(version3);
  }
});

// ../../node_modules/ethers/lib.esm/index.js
var lib_exports7 = {};
__export(lib_exports7, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  ethers: () => ethers_exports,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger3,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version3,
  wordlists: () => wordlists
});
var init_lib28 = __esm({
  "../../node_modules/ethers/lib.esm/index.js"() {
    init_ethers();
    init_ethers();
    try {
      const anyGlobal = window;
      if (anyGlobal._ethers == null) {
        anyGlobal._ethers = ethers_exports;
      }
    } catch (error) {
    }
  }
});

export {
  lib_exports5 as lib_exports,
  init_lib26 as init_lib,
  lib_exports6 as lib_exports2,
  init_lib27 as init_lib2,
  utils_exports,
  version3 as version,
  logger3 as logger,
  ethers_exports,
  lib_exports7 as lib_exports3,
  init_lib28 as init_lib3
};
//# sourceMappingURL=chunk-YWBGZ5UC.js.map
