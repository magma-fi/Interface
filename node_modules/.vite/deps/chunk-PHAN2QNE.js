import {
  inherits_default,
  init_util,
  inspect,
  isDate,
  isError,
  isFunction,
  isPrimitive,
  isRegExp
} from "./chunk-M2ER3SZV.js";
import {
  init_lib,
  lib_exports
} from "./chunk-WJIB2CDQ.js";
import {
  init_buffer,
  isBuffer
} from "./chunk-5AVNCSA7.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-W7S2ME4R.js";

// node-modules-polyfills:assert
var assert_exports = {};
__export(assert_exports, {
  AssertionError: () => AssertionError,
  assert: () => ok,
  deepEqual: () => deepEqual,
  deepStrictEqual: () => deepStrictEqual,
  default: () => assert_default,
  doesNotThrow: () => doesNotThrow,
  equal: () => equal,
  fail: () => fail,
  ifError: () => ifError,
  notDeepEqual: () => notDeepEqual,
  notDeepStrictEqual: () => notDeepStrictEqual,
  notEqual: () => notEqual,
  notStrictEqual: () => notStrictEqual,
  ok: () => ok,
  strictEqual: () => strictEqual,
  throws: () => throws
});
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof globalThis.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err = new Error();
    if (err.stack) {
      var out = err.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
function truncate(s, n) {
  if (typeof s === "string") {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect2(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self) {
  return truncate(inspect2(self.actual), 128) + " " + self.operator + " " + truncate(inspect2(self.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
function ok(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function equal(actual, expected, message) {
  if (actual != expected)
    fail(actual, expected, message, "==", equal);
}
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === void 0 || b === null || b === void 0)
    return false;
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
function throws(block, error, message) {
  _throws(true, block, error, message);
}
function doesNotThrow(block, error, message) {
  _throws(false, block, error, message);
}
function ifError(err) {
  if (err)
    throw err;
}
var hasOwn, objectKeys, pSlice, _functionsHaveNames, assert_default, regex;
var init_assert = __esm({
  "node-modules-polyfills:assert"() {
    init_buffer();
    init_util();
    hasOwn = Object.prototype.hasOwnProperty;
    objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key))
          keys.push(key);
      }
      return keys;
    };
    pSlice = Array.prototype.slice;
    assert_default = assert;
    regex = /\s*function\s+([^\(\s]*)\s*/;
    assert.AssertionError = AssertionError;
    inherits_default(AssertionError, Error);
    assert.fail = fail;
    assert.ok = ok;
    assert.equal = equal;
    assert.notEqual = notEqual;
    assert.deepEqual = deepEqual;
    assert.deepStrictEqual = deepStrictEqual;
    assert.notDeepEqual = notDeepEqual;
    assert.notDeepStrictEqual = notDeepStrictEqual;
    assert.strictEqual = strictEqual;
    assert.notStrictEqual = notStrictEqual;
    assert.throws = throws;
    assert.doesNotThrow = doesNotThrow;
    assert.ifError = ifError;
  }
});

// node-modules-polyfills-commonjs:assert
var require_assert = __commonJS({
  "node-modules-polyfills-commonjs:assert"(exports, module) {
    var polyfill = (init_assert(), __toCommonJS(assert_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// ../lib-base/dist/src/Decimal.js
var require_Decimal = __commonJS({
  "../lib-base/dist/src/Decimal.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Percent = exports.Difference = exports.Decimal = void 0;
    var assert_1 = __importDefault(require_assert());
    var bignumber_1 = (init_lib(), __toCommonJS(lib_exports));
    var getDigits = (numDigits) => TEN.pow(numDigits);
    var MAX_UINT_256 = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
    var PRECISION = 18;
    var ONE = bignumber_1.BigNumber.from(1);
    var TEN = bignumber_1.BigNumber.from(10);
    var DIGITS = getDigits(PRECISION);
    var stringRepresentationFormat = /^[0-9]*(\.[0-9]*)?(e[-+]?[0-9]+)?$/;
    var trailingZeros = /0*$/;
    var magnitudes = ["", "K", "M", "B", "T"];
    var roundedMul = (x, y) => x.mul(y).add(Decimal.HALF.hex).div(DIGITS);
    var Decimal = class _Decimal {
      constructor(bigNumber) {
        if (bigNumber.isNegative()) {
          throw new Error("negatives not supported by Decimal");
        }
        this._bigNumber = bigNumber;
      }
      /** @internal */
      get hex() {
        return this._bigNumber.toHexString();
      }
      /** @internal */
      get bigNumber() {
        return this._bigNumber.toString();
      }
      static fromBigNumberString(bigNumberString) {
        return new _Decimal(bignumber_1.BigNumber.from(bigNumberString));
      }
      static _fromString(representation) {
        if (!representation || !representation.match(stringRepresentationFormat)) {
          throw new Error(`bad decimal format: "${representation}"`);
        }
        if (representation.includes("e")) {
          let [coefficient, exponent] = representation.split("e");
          if (exponent.startsWith("-")) {
            return new _Decimal(_Decimal._fromString(coefficient)._bigNumber.div(TEN.pow(bignumber_1.BigNumber.from(exponent.substr(1)))));
          }
          if (exponent.startsWith("+")) {
            exponent = exponent.substr(1);
          }
          return new _Decimal(_Decimal._fromString(coefficient)._bigNumber.mul(TEN.pow(bignumber_1.BigNumber.from(exponent))));
        }
        if (!representation.includes(".")) {
          return new _Decimal(bignumber_1.BigNumber.from(representation).mul(DIGITS));
        }
        let [characteristic, mantissa] = representation.split(".");
        if (mantissa.length < PRECISION) {
          mantissa += "0".repeat(PRECISION - mantissa.length);
        } else {
          mantissa = mantissa.substr(0, PRECISION);
        }
        return new _Decimal(bignumber_1.BigNumber.from(characteristic || 0).mul(DIGITS).add(mantissa));
      }
      static from(decimalish) {
        if (typeof decimalish === "object" && decimalish instanceof bignumber_1.BigNumber) {
          console.debug("lib-base: 转换大数时传入了BigNumber", decimalish);
          return _Decimal.from(decimalish.toString());
        }
        switch (typeof decimalish) {
          case "object":
            console.debug("lib-base: 转换大数时进行判断", decimalish instanceof _Decimal);
            if (decimalish instanceof _Decimal) {
              return decimalish;
            } else {
              console.debug("lib-base: 转换大数时报错0", decimalish, typeof decimalish);
              throw new Error("invalid Decimalish value");
            }
          case "string":
            return _Decimal._fromString(decimalish);
          case "number":
            return _Decimal._fromString(decimalish.toString());
          default:
            console.debug("lib-base: 转换大数时报错1", decimalish, typeof decimalish);
            throw new Error("invalid Decimalish value");
        }
      }
      _toStringWithAutomaticPrecision() {
        const characteristic = this._bigNumber.div(DIGITS);
        const mantissa = this._bigNumber.mod(DIGITS);
        if (mantissa.isZero()) {
          return characteristic.toString();
        } else {
          const paddedMantissa = mantissa.toString().padStart(PRECISION, "0");
          const trimmedMantissa = paddedMantissa.replace(trailingZeros, "");
          return characteristic.toString() + "." + trimmedMantissa;
        }
      }
      _roundUp(precision) {
        const halfDigit = getDigits(PRECISION - 1 - precision).mul(5);
        return this._bigNumber.add(halfDigit);
      }
      _toStringWithPrecision(precision) {
        if (precision < 0) {
          throw new Error("precision must not be negative");
        }
        const value = precision < PRECISION ? this._roundUp(precision) : this._bigNumber;
        const characteristic = value.div(DIGITS);
        const mantissa = value.mod(DIGITS);
        if (precision === 0) {
          return characteristic.toString();
        } else {
          const paddedMantissa = mantissa.toString().padStart(PRECISION, "0");
          const trimmedMantissa = paddedMantissa.substr(0, precision);
          return characteristic.toString() + "." + trimmedMantissa;
        }
      }
      toString(precision) {
        if (this.infinite) {
          return "∞";
        } else if (precision !== void 0) {
          return this._toStringWithPrecision(precision);
        } else {
          return this._toStringWithAutomaticPrecision();
        }
      }
      prettify(precision = 2) {
        const [characteristic, mantissa] = this.toString(precision).split(".");
        const prettyCharacteristic = characteristic.replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
        return mantissa !== void 0 ? prettyCharacteristic + "." + mantissa : prettyCharacteristic;
      }
      shorten() {
        const characteristicLength = this.toString(0).length;
        const magnitude = Math.min(Math.floor((characteristicLength - 1) / 3), magnitudes.length - 1);
        const precision = Math.max(3 * (magnitude + 1) - characteristicLength, 0);
        const normalized = this.div(new _Decimal(getDigits(PRECISION + 3 * magnitude)));
        return normalized.prettify(precision) + magnitudes[magnitude];
      }
      add(addend) {
        return new _Decimal(this._bigNumber.add(_Decimal.from(addend)._bigNumber));
      }
      sub(subtrahend) {
        return new _Decimal(this._bigNumber.sub(_Decimal.from(subtrahend)._bigNumber));
      }
      mul(multiplier) {
        return new _Decimal(this._bigNumber.mul(_Decimal.from(multiplier)._bigNumber).div(DIGITS));
      }
      div(divider) {
        divider = _Decimal.from(divider);
        if (divider.isZero) {
          return _Decimal.INFINITY;
        }
        return new _Decimal(this._bigNumber.mul(DIGITS).div(divider._bigNumber));
      }
      /** @internal */
      _divCeil(divider) {
        divider = _Decimal.from(divider);
        if (divider.isZero) {
          return _Decimal.INFINITY;
        }
        return new _Decimal(this._bigNumber.mul(DIGITS).add(divider._bigNumber.sub(ONE)).div(divider._bigNumber));
      }
      mulDiv(multiplier, divider) {
        multiplier = _Decimal.from(multiplier);
        divider = _Decimal.from(divider);
        if (divider.isZero) {
          return _Decimal.INFINITY;
        }
        return new _Decimal(this._bigNumber.mul(multiplier._bigNumber).div(divider._bigNumber));
      }
      pow(exponent) {
        assert_1.default(Number.isInteger(exponent));
        assert_1.default(0 <= exponent && exponent <= 4294967295);
        if (exponent === 0) {
          return _Decimal.ONE;
        }
        if (exponent === 1) {
          return this;
        }
        let x = this._bigNumber;
        let y = DIGITS;
        for (; exponent > 1; exponent >>>= 1) {
          if (exponent & 1) {
            y = roundedMul(x, y);
          }
          x = roundedMul(x, x);
        }
        return new _Decimal(roundedMul(x, y));
      }
      get isZero() {
        return this._bigNumber.isZero();
      }
      get zero() {
        if (this.isZero) {
          return this;
        }
      }
      get nonZero() {
        if (!this.isZero) {
          return this;
        }
      }
      get infinite() {
        if (this.eq(_Decimal.INFINITY)) {
          return this;
        }
      }
      get finite() {
        if (!this.eq(_Decimal.INFINITY)) {
          return this;
        }
      }
      /** @internal */
      get absoluteValue() {
        return this;
      }
      lt(that) {
        return this._bigNumber.lt(_Decimal.from(that)._bigNumber);
      }
      eq(that) {
        return this._bigNumber.eq(_Decimal.from(that)._bigNumber);
      }
      gt(that) {
        return this._bigNumber.gt(_Decimal.from(that)._bigNumber);
      }
      gte(that) {
        return this._bigNumber.gte(_Decimal.from(that)._bigNumber);
      }
      lte(that) {
        return this._bigNumber.lte(_Decimal.from(that)._bigNumber);
      }
      static min(a, b) {
        a = _Decimal.from(a);
        b = _Decimal.from(b);
        return a.lt(b) ? a : b;
      }
      static max(a, b) {
        a = _Decimal.from(a);
        b = _Decimal.from(b);
        return a.gt(b) ? a : b;
      }
    };
    exports.Decimal = Decimal;
    Decimal.INFINITY = Decimal.fromBigNumberString(MAX_UINT_256);
    Decimal.ZERO = Decimal.from(0);
    Decimal.HALF = Decimal.from(0.5);
    Decimal.ONE = Decimal.from(1);
    var Difference = class _Difference {
      constructor(number) {
        this._number = number;
      }
      static between(d1, d2) {
        if (d1 === void 0 || d2 === void 0) {
          return new _Difference(void 0);
        }
        d1 = Decimal.from(d1);
        d2 = Decimal.from(d2);
        if (d1.infinite && d2.infinite) {
          return new _Difference(void 0);
        } else if (d1.infinite) {
          return new _Difference({ sign: "+", absoluteValue: d1 });
        } else if (d2.infinite) {
          return new _Difference({ sign: "-", absoluteValue: d2 });
        } else if (d1.gt(d2)) {
          return new _Difference({ sign: "+", absoluteValue: Decimal.from(d1).sub(d2) });
        } else if (d2.gt(d1)) {
          return new _Difference({ sign: "-", absoluteValue: Decimal.from(d2).sub(d1) });
        } else {
          return new _Difference({ sign: "", absoluteValue: Decimal.ZERO });
        }
      }
      toString(precision) {
        if (!this._number) {
          return "N/A";
        }
        return this._number.sign + this._number.absoluteValue.toString(precision);
      }
      prettify(precision) {
        if (!this._number) {
          return this.toString();
        }
        return this._number.sign + this._number.absoluteValue.prettify(precision);
      }
      mul(multiplier) {
        return new _Difference(this._number && {
          sign: this._number.sign,
          absoluteValue: this._number.absoluteValue.mul(multiplier)
        });
      }
      get nonZero() {
        var _a;
        return ((_a = this._number) === null || _a === void 0 ? void 0 : _a.absoluteValue.nonZero) && this;
      }
      get positive() {
        var _a;
        return ((_a = this._number) === null || _a === void 0 ? void 0 : _a.sign) === "+" ? this : void 0;
      }
      get negative() {
        var _a;
        return ((_a = this._number) === null || _a === void 0 ? void 0 : _a.sign) === "-" ? this : void 0;
      }
      get absoluteValue() {
        var _a;
        return (_a = this._number) === null || _a === void 0 ? void 0 : _a.absoluteValue;
      }
      get infinite() {
        var _a;
        return ((_a = this._number) === null || _a === void 0 ? void 0 : _a.absoluteValue.infinite) && this;
      }
      get finite() {
        var _a;
        return ((_a = this._number) === null || _a === void 0 ? void 0 : _a.absoluteValue.finite) && this;
      }
    };
    exports.Difference = Difference;
    var Percent = class {
      constructor(ratio) {
        this._percent = ratio.infinite || ratio.mul && ratio.mul(100) || ratio;
      }
      nonZeroish(precision) {
        var _a;
        const zeroish = `0.${"0".repeat(precision)}5`;
        if ((_a = this._percent.absoluteValue) === null || _a === void 0 ? void 0 : _a.gte(zeroish)) {
          return this;
        }
      }
      toString(precision) {
        return this._percent.toString(precision) + (this._percent.absoluteValue && !this._percent.infinite ? "%" : "");
      }
      prettify() {
        var _a, _b;
        if ((_a = this._percent.absoluteValue) === null || _a === void 0 ? void 0 : _a.gte("1000")) {
          return this.toString(0);
        } else if ((_b = this._percent.absoluteValue) === null || _b === void 0 ? void 0 : _b.gte("10")) {
          return this.toString(1);
        } else {
          return this.toString(2);
        }
      }
    };
    exports.Percent = Percent;
  }
});

// ../lib-base/dist/src/constants.js
var require_constants = __commonJS({
  "../lib-base/dist/src/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MINIMUM_REDEMPTION_RATE = exports.MAXIMUM_BORROWING_RATE = exports.MINIMUM_BORROWING_RATE = exports.LUSD_MINIMUM_DEBT = exports.LUSD_MINIMUM_NET_DEBT = exports.LUSD_LIQUIDATION_RESERVE = exports.MINIMUM_COLLATERAL_RATIO = exports.CRITICAL_COLLATERAL_RATIO = void 0;
    var Decimal_1 = require_Decimal();
    exports.CRITICAL_COLLATERAL_RATIO = Decimal_1.Decimal.from(1.5);
    exports.MINIMUM_COLLATERAL_RATIO = Decimal_1.Decimal.from(1.1);
    exports.LUSD_LIQUIDATION_RESERVE = Decimal_1.Decimal.from(1);
    exports.LUSD_MINIMUM_NET_DEBT = Decimal_1.Decimal.from(1800);
    exports.LUSD_MINIMUM_DEBT = exports.LUSD_LIQUIDATION_RESERVE.add(exports.LUSD_MINIMUM_NET_DEBT);
    exports.MINIMUM_BORROWING_RATE = Decimal_1.Decimal.from(5e-3);
    exports.MAXIMUM_BORROWING_RATE = Decimal_1.Decimal.from(0.05);
    exports.MINIMUM_REDEMPTION_RATE = Decimal_1.Decimal.from(5e-3);
  }
});

// ../lib-base/dist/src/Trove.js
var require_Trove = __commonJS({
  "../lib-base/dist/src/Trove.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TroveWithPendingRedistribution = exports.UserTrove = exports._emptyTrove = exports.Trove = exports._normalizeTroveAdjustment = exports._normalizeTroveCreation = void 0;
    var assert_1 = __importDefault(require_assert());
    var Decimal_1 = require_Decimal();
    var constants_1 = require_constants();
    var invalidTroveCreation = (invalidTrove, error) => ({
      type: "invalidCreation",
      invalidTrove,
      error
    });
    var troveCreation = (params) => ({
      type: "creation",
      params
    });
    var troveClosure = (params) => ({
      type: "closure",
      params
    });
    var troveAdjustment = (params, setToZero) => ({
      type: "adjustment",
      params,
      setToZero
    });
    var valueIsDefined = (entry) => entry[1] !== void 0;
    var allowedTroveCreationKeys = [
      "depositCollateral",
      "borrowLUSD"
    ];
    function checkAllowedTroveCreationKeys(entries) {
      const badKeys = entries.filter(([k]) => !allowedTroveCreationKeys.includes(k)).map(([k]) => `'${k}'`);
      if (badKeys.length > 0) {
        throw new Error(`TroveCreationParams: property ${badKeys.join(", ")} not allowed`);
      }
    }
    var troveCreationParamsFromEntries = (entries) => {
      const params = Object.fromEntries(entries);
      const missingKeys = allowedTroveCreationKeys.filter((k) => !(k in params)).map((k) => `'${k}'`);
      if (missingKeys.length > 0) {
        throw new Error(`TroveCreationParams: property ${missingKeys.join(", ")} missing`);
      }
      return params;
    };
    var decimalize = ([k, v]) => [k, Decimal_1.Decimal.from(v)];
    var nonZero = ([, v]) => !v.isZero;
    var _normalizeTroveCreation = (params) => {
      const definedEntries = Object.entries(params).filter(valueIsDefined);
      checkAllowedTroveCreationKeys(definedEntries);
      const nonZeroEntries = definedEntries.map(decimalize);
      return troveCreationParamsFromEntries(nonZeroEntries);
    };
    exports._normalizeTroveCreation = _normalizeTroveCreation;
    var allowedTroveAdjustmentKeys = [
      "depositCollateral",
      "withdrawCollateral",
      "borrowLUSD",
      "repayLUSD"
    ];
    function checkAllowedTroveAdjustmentKeys(entries) {
      const badKeys = entries.filter(([k]) => !allowedTroveAdjustmentKeys.includes(k)).map(([k]) => `'${k}'`);
      if (badKeys.length > 0) {
        throw new Error(`TroveAdjustmentParams: property ${badKeys.join(", ")} not allowed`);
      }
    }
    var collateralChangeFrom = ({ depositCollateral, withdrawCollateral }) => {
      if (depositCollateral !== void 0 && withdrawCollateral !== void 0) {
        throw new Error("TroveAdjustmentParams: 'depositCollateral' and 'withdrawCollateral' can't be present at the same time");
      }
      if (depositCollateral !== void 0) {
        return { depositCollateral };
      }
      if (withdrawCollateral !== void 0) {
        return { withdrawCollateral };
      }
    };
    var debtChangeFrom = ({ borrowLUSD, repayLUSD }) => {
      if (borrowLUSD !== void 0 && repayLUSD !== void 0) {
        throw new Error("TroveAdjustmentParams: 'borrowLUSD' and 'repayLUSD' can't be present at the same time");
      }
      if (borrowLUSD !== void 0) {
        return { borrowLUSD };
      }
      if (repayLUSD !== void 0) {
        return { repayLUSD };
      }
    };
    var troveAdjustmentParamsFromEntries = (entries) => {
      const params = Object.fromEntries(entries);
      const collateralChange = collateralChangeFrom(params);
      const debtChange = debtChangeFrom(params);
      if (collateralChange !== void 0 && debtChange !== void 0) {
        return { ...collateralChange, ...debtChange };
      }
      if (collateralChange !== void 0) {
        return collateralChange;
      }
      if (debtChange !== void 0) {
        return debtChange;
      }
      throw new Error("TroveAdjustmentParams: must include at least one non-zero parameter");
    };
    var _normalizeTroveAdjustment = (params) => {
      const definedEntries = Object.entries(params).filter(valueIsDefined);
      checkAllowedTroveAdjustmentKeys(definedEntries);
      const nonZeroEntries = definedEntries.map(decimalize).filter(nonZero);
      return troveAdjustmentParamsFromEntries(nonZeroEntries);
    };
    exports._normalizeTroveAdjustment = _normalizeTroveAdjustment;
    var applyFee = (borrowingRate, debtIncrease) => debtIncrease.mul(Decimal_1.Decimal.ONE.add(borrowingRate));
    var unapplyFee = (borrowingRate, debtIncrease) => debtIncrease._divCeil(Decimal_1.Decimal.ONE.add(borrowingRate));
    var NOMINAL_COLLATERAL_RATIO_PRECISION = Decimal_1.Decimal.from(100);
    var Trove = class _Trove {
      /** @internal */
      constructor(collateral = Decimal_1.Decimal.ZERO, debt = Decimal_1.Decimal.ZERO) {
        this.collateral = collateral;
        this.debt = debt;
      }
      get isEmpty() {
        return this.collateral.isZero && this.debt.isZero;
      }
      /**
       * Amount of LUSD that must be repaid to close this Trove.
       *
       * @remarks
       * This doesn't include the liquidation reserve, which is refunded in case of normal closure.
       */
      get netDebt() {
        if (this.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {
          throw new Error(`netDebt should not be used when debt < ${constants_1.LUSD_LIQUIDATION_RESERVE}`);
        }
        return this.debt.sub(constants_1.LUSD_LIQUIDATION_RESERVE);
      }
      /** @internal */
      get _nominalCollateralRatio() {
        return this.collateral.mulDiv(NOMINAL_COLLATERAL_RATIO_PRECISION, this.debt);
      }
      /** Calculate the Trove's collateralization ratio at a given price. */
      collateralRatio(price) {
        return this.collateral.mulDiv(price, this.debt);
      }
      /**
       * Whether the Trove is undercollateralized at a given price.
       *
       * @returns
       * `true` if the Trove's collateralization ratio is less than the
       * {@link MINIMUM_COLLATERAL_RATIO}.
       */
      collateralRatioIsBelowMinimum(price) {
        return this.collateralRatio(price).lt(constants_1.MINIMUM_COLLATERAL_RATIO);
      }
      /**
       * Whether the collateralization ratio is less than the {@link CRITICAL_COLLATERAL_RATIO} at a
       * given price.
       *
       * @example
       * Can be used to check whether the Liquity protocol is in recovery mode by using it on the return
       * value of {@link ReadableLiquity.getTotal | getTotal()}. For example:
       *
       * ```typescript
       * const total = await liquity.getTotal();
       * const price = await liquity.getPrice();
       *
       * if (total.collateralRatioIsBelowCritical(price)) {
       *   // Recovery mode is active
       * }
       * ```
       */
      collateralRatioIsBelowCritical(price) {
        return this.collateralRatio(price).lt(constants_1.CRITICAL_COLLATERAL_RATIO);
      }
      /** Whether the Trove is sufficiently collateralized to be opened during recovery mode. */
      isOpenableInRecoveryMode(price) {
        return this.collateralRatio(price).gte(constants_1.CRITICAL_COLLATERAL_RATIO);
      }
      /** @internal */
      toString() {
        return `{ collateral: ${this.collateral}, debt: ${this.debt} }`;
      }
      equals(that) {
        return this.collateral.eq(that.collateral) && this.debt.eq(that.debt);
      }
      add(that) {
        return new _Trove(this.collateral.add(that.collateral), this.debt.add(that.debt));
      }
      addCollateral(collateral) {
        return new _Trove(this.collateral.add(collateral), this.debt);
      }
      addDebt(debt) {
        return new _Trove(this.collateral, this.debt.add(debt));
      }
      subtract(that) {
        const { collateral, debt } = that;
        return new _Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);
      }
      subtractCollateral(collateral) {
        return new _Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt);
      }
      subtractDebt(debt) {
        return new _Trove(this.collateral, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);
      }
      multiply(multiplier) {
        return new _Trove(this.collateral.mul(multiplier), this.debt.mul(multiplier));
      }
      setCollateral(collateral) {
        return new _Trove(Decimal_1.Decimal.from(collateral), this.debt);
      }
      setDebt(debt) {
        return new _Trove(this.collateral, Decimal_1.Decimal.from(debt));
      }
      _debtChange({ debt }, borrowingRate) {
        return debt.gt(this.debt) ? { borrowLUSD: unapplyFee(borrowingRate, debt.sub(this.debt)) } : { repayLUSD: this.debt.sub(debt) };
      }
      _collateralChange({ collateral }) {
        return collateral.gt(this.collateral) ? { depositCollateral: collateral.sub(this.collateral) } : { withdrawCollateral: this.collateral.sub(collateral) };
      }
      /**
       * Calculate the difference between this Trove and another.
       *
       * @param that - The other Trove.
       * @param borrowingRate - Borrowing rate to use when calculating a borrowed amount.
       *
       * @returns
       * An object representing the change, or `undefined` if the Troves are equal.
       */
      whatChanged(that, borrowingRate = constants_1.MINIMUM_BORROWING_RATE) {
        var _a;
        if (this.collateral.eq(that.collateral) && this.debt.eq(that.debt)) {
          return void 0;
        }
        if (this.isEmpty) {
          if (that.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {
            return invalidTroveCreation(that, "missingLiquidationReserve");
          }
          return troveCreation({
            depositCollateral: that.collateral,
            borrowLUSD: unapplyFee(borrowingRate, that.netDebt)
          });
        }
        if (that.isEmpty) {
          return troveClosure(this.netDebt.nonZero ? { withdrawCollateral: this.collateral, repayLUSD: this.netDebt } : { withdrawCollateral: this.collateral });
        }
        return this.collateral.eq(that.collateral) ? troveAdjustment(this._debtChange(that, borrowingRate), that.debt.zero && "debt") : this.debt.eq(that.debt) ? troveAdjustment(this._collateralChange(that), that.collateral.zero && "collateral") : troveAdjustment({
          ...this._debtChange(that, borrowingRate),
          ...this._collateralChange(that)
        }, (_a = that.debt.zero && "debt") !== null && _a !== void 0 ? _a : that.collateral.zero && "collateral");
      }
      /**
       * Make a new Trove by applying a {@link TroveChange} to this Trove.
       *
       * @param change - The change to apply.
       * @param borrowingRate - Borrowing rate to use when adding a borrowed amount to the Trove's debt.
       */
      apply(change, borrowingRate = constants_1.MINIMUM_BORROWING_RATE) {
        if (!change) {
          return this;
        }
        switch (change.type) {
          case "invalidCreation":
            if (!this.isEmpty) {
              throw new Error("Can't create onto existing Trove");
            }
            return change.invalidTrove;
          case "creation": {
            if (!this.isEmpty) {
              throw new Error("Can't create onto existing Trove");
            }
            const { depositCollateral, borrowLUSD } = change.params;
            return new _Trove(depositCollateral, constants_1.LUSD_LIQUIDATION_RESERVE.add(applyFee(borrowingRate, borrowLUSD)));
          }
          case "closure":
            if (this.isEmpty) {
              throw new Error("Can't close empty Trove");
            }
            return exports._emptyTrove;
          case "adjustment": {
            const { setToZero, params: { depositCollateral, withdrawCollateral, borrowLUSD, repayLUSD } } = change;
            const collateralDecrease = withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : Decimal_1.Decimal.ZERO;
            const collateralIncrease = depositCollateral !== null && depositCollateral !== void 0 ? depositCollateral : Decimal_1.Decimal.ZERO;
            const debtDecrease = repayLUSD !== null && repayLUSD !== void 0 ? repayLUSD : Decimal_1.Decimal.ZERO;
            const debtIncrease = borrowLUSD ? applyFee(borrowingRate, borrowLUSD) : Decimal_1.Decimal.ZERO;
            return setToZero === "collateral" ? this.setCollateral(Decimal_1.Decimal.ZERO).addDebt(debtIncrease).subtractDebt(debtDecrease) : setToZero === "debt" ? this.setDebt(Decimal_1.Decimal.ZERO).addCollateral(collateralIncrease).subtractCollateral(collateralDecrease) : this.add(new _Trove(collateralIncrease, debtIncrease)).subtract(new _Trove(collateralDecrease, debtDecrease));
          }
        }
      }
      /**
       * Calculate the result of an {@link TransactableLiquity.openTrove | openTrove()} transaction.
       *
       * @param params - Parameters of the transaction.
       * @param borrowingRate - Borrowing rate to use when calculating the Trove's debt.
       */
      static create(params, borrowingRate) {
        return exports._emptyTrove.apply(troveCreation(exports._normalizeTroveCreation(params)), borrowingRate);
      }
      /**
       * Calculate the parameters of an {@link TransactableLiquity.openTrove | openTrove()} transaction
       * that will result in the given Trove.
       *
       * @param that - The Trove to recreate.
       * @param borrowingRate - Current borrowing rate.
       */
      static recreate(that, borrowingRate) {
        const change = exports._emptyTrove.whatChanged(that, borrowingRate);
        assert_1.default((change === null || change === void 0 ? void 0 : change.type) === "creation");
        return change.params;
      }
      /**
       * Calculate the result of an {@link TransactableLiquity.adjustTrove | adjustTrove()} transaction
       * on this Trove.
       *
       * @param params - Parameters of the transaction.
       * @param borrowingRate - Borrowing rate to use when adding to the Trove's debt.
       */
      adjust(params, borrowingRate) {
        return this.apply(troveAdjustment(exports._normalizeTroveAdjustment(params)), borrowingRate);
      }
      /**
       * Calculate the parameters of an {@link TransactableLiquity.adjustTrove | adjustTrove()}
       * transaction that will change this Trove into the given Trove.
       *
       * @param that - The desired result of the transaction.
       * @param borrowingRate - Current borrowing rate.
       */
      adjustTo(that, borrowingRate) {
        const change = this.whatChanged(that, borrowingRate);
        assert_1.default((change === null || change === void 0 ? void 0 : change.type) === "adjustment");
        return change.params;
      }
    };
    exports.Trove = Trove;
    exports._emptyTrove = new Trove();
    var UserTrove = class extends Trove {
      /** @internal */
      constructor(ownerAddress, status, collateral, debt) {
        super(collateral, debt);
        this.ownerAddress = ownerAddress;
        this.status = status;
      }
      equals(that) {
        return super.equals(that) && this.ownerAddress === that.ownerAddress && this.status === that.status;
      }
      /** @internal */
      toString() {
        return `{ ownerAddress: "${this.ownerAddress}", collateral: ${this.collateral}, debt: ${this.debt}, status: "${this.status}" }`;
      }
    };
    exports.UserTrove = UserTrove;
    var TroveWithPendingRedistribution = class extends UserTrove {
      /** @internal */
      constructor(ownerAddress, status, collateral, debt, stake = Decimal_1.Decimal.ZERO, snapshotOfTotalRedistributed = exports._emptyTrove) {
        super(ownerAddress, status, collateral, debt);
        this.stake = stake;
        this.snapshotOfTotalRedistributed = snapshotOfTotalRedistributed;
      }
      applyRedistribution(totalRedistributed) {
        const afterRedistribution = this.add(totalRedistributed.subtract(this.snapshotOfTotalRedistributed).multiply(this.stake));
        return new UserTrove(this.ownerAddress, this.status, afterRedistribution.collateral, afterRedistribution.debt);
      }
      equals(that) {
        return super.equals(that) && this.stake.eq(that.stake) && this.snapshotOfTotalRedistributed.equals(that.snapshotOfTotalRedistributed);
      }
    };
    exports.TroveWithPendingRedistribution = TroveWithPendingRedistribution;
  }
});

// ../lib-base/dist/src/StabilityDeposit.js
var require_StabilityDeposit = __commonJS({
  "../lib-base/dist/src/StabilityDeposit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StabilityDeposit = void 0;
    var Decimal_1 = require_Decimal();
    var StabilityDeposit = class {
      /** @internal */
      constructor(initialLUSD, currentLUSD, collateralGain, lqtyReward, frontendTag) {
        this.initialLUSD = initialLUSD;
        this.currentLUSD = currentLUSD;
        this.collateralGain = collateralGain;
        this.lqtyReward = lqtyReward;
        this.frontendTag = frontendTag;
        if (this.currentLUSD.gt(this.initialLUSD)) {
          throw new Error("currentLUSD can't be greater than initialLUSD");
        }
      }
      get isEmpty() {
        return this.initialLUSD.isZero && this.currentLUSD.isZero && this.collateralGain.isZero && this.lqtyReward.isZero;
      }
      /** @internal */
      toString() {
        return `{ initialLUSD: ${this.initialLUSD}, currentLUSD: ${this.currentLUSD}, collateralGain: ${this.collateralGain}, lqtyReward: ${this.lqtyReward}, frontendTag: "${this.frontendTag}" }`;
      }
      /**
       * Compare to another instance of `StabilityDeposit`.
       */
      equals(that) {
        return this.initialLUSD.eq(that.initialLUSD) && this.currentLUSD.eq(that.currentLUSD) && this.collateralGain.eq(that.collateralGain) && this.lqtyReward.eq(that.lqtyReward) && this.frontendTag === that.frontendTag;
      }
      /**
       * Calculate the difference between the `currentLUSD` in this Stability Deposit and `thatLUSD`.
       *
       * @returns An object representing the change, or `undefined` if the deposited amounts are equal.
       */
      whatChanged(thatLUSD) {
        thatLUSD = Decimal_1.Decimal.from(thatLUSD);
        if (thatLUSD.lt(this.currentLUSD)) {
          return { withdrawLUSD: this.currentLUSD.sub(thatLUSD), withdrawAllLUSD: thatLUSD.isZero };
        }
        if (thatLUSD.gt(this.currentLUSD)) {
          return { depositLUSD: thatLUSD.sub(this.currentLUSD) };
        }
      }
      /**
       * Apply a {@link StabilityDepositChange} to this Stability Deposit.
       *
       * @returns The new deposited LUSD amount.
       */
      apply(change) {
        if (!change) {
          return this.currentLUSD;
        }
        if (change.withdrawLUSD !== void 0) {
          return change.withdrawAllLUSD || this.currentLUSD.lte(change.withdrawLUSD) ? Decimal_1.Decimal.ZERO : this.currentLUSD.sub(change.withdrawLUSD);
        } else {
          return this.currentLUSD.add(change.depositLUSD);
        }
      }
    };
    exports.StabilityDeposit = StabilityDeposit;
  }
});

// ../lib-base/dist/src/LQTYStake.js
var require_LQTYStake = __commonJS({
  "../lib-base/dist/src/LQTYStake.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LQTYStake = void 0;
    var Decimal_1 = require_Decimal();
    var LQTYStake = class {
      /** @internal */
      constructor(stakedLQTY = Decimal_1.Decimal.ZERO, collateralGain = Decimal_1.Decimal.ZERO, lusdGain = Decimal_1.Decimal.ZERO) {
        this.stakedLQTY = stakedLQTY;
        this.collateralGain = collateralGain;
        this.lusdGain = lusdGain;
      }
      get isEmpty() {
        return this.stakedLQTY.isZero && this.collateralGain.isZero && this.lusdGain.isZero;
      }
      /** @internal */
      toString() {
        return `{ stakedLQTY: ${this.stakedLQTY}, collateralGain: ${this.collateralGain}, lusdGain: ${this.lusdGain} }`;
      }
      /**
       * Compare to another instance of `LQTYStake`.
       */
      equals(that) {
        return this.stakedLQTY.eq(that.stakedLQTY) && this.collateralGain.eq(that.collateralGain) && this.lusdGain.eq(that.lusdGain);
      }
      /**
       * Calculate the difference between this `LQTYStake` and `thatStakedLQTY`.
       *
       * @returns An object representing the change, or `undefined` if the staked amounts are equal.
       */
      whatChanged(thatStakedLQTY) {
        thatStakedLQTY = Decimal_1.Decimal.from(thatStakedLQTY);
        if (thatStakedLQTY.lt(this.stakedLQTY)) {
          return {
            unstakeLQTY: this.stakedLQTY.sub(thatStakedLQTY),
            unstakeAllLQTY: thatStakedLQTY.isZero
          };
        }
        if (thatStakedLQTY.gt(this.stakedLQTY)) {
          return { stakeLQTY: thatStakedLQTY.sub(this.stakedLQTY) };
        }
      }
      /**
       * Apply a {@link LQTYStakeChange} to this `LQTYStake`.
       *
       * @returns The new staked LQTY amount.
       */
      apply(change) {
        if (!change) {
          return this.stakedLQTY;
        }
        if (change.unstakeLQTY !== void 0) {
          return change.unstakeAllLQTY || this.stakedLQTY.lte(change.unstakeLQTY) ? Decimal_1.Decimal.ZERO : this.stakedLQTY.sub(change.unstakeLQTY);
        } else {
          return this.stakedLQTY.add(change.stakeLQTY);
        }
      }
    };
    exports.LQTYStake = LQTYStake;
  }
});

// ../lib-base/dist/src/Fees.js
var require_Fees = __commonJS({
  "../lib-base/dist/src/Fees.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Fees = void 0;
    var assert_1 = __importDefault(require_assert());
    var Decimal_1 = require_Decimal();
    var constants_1 = require_constants();
    var Fees = class _Fees {
      /** @internal */
      constructor(baseRateWithoutDecay, minuteDecayFactor, beta, lastFeeOperation, timeOfLatestBlock, recoveryMode) {
        this._baseRateWithoutDecay = Decimal_1.Decimal.from(baseRateWithoutDecay);
        this._minuteDecayFactor = Decimal_1.Decimal.from(minuteDecayFactor);
        this._beta = Decimal_1.Decimal.from(beta);
        this._lastFeeOperation = lastFeeOperation;
        this._timeOfLatestBlock = timeOfLatestBlock;
        this._recoveryMode = recoveryMode;
        assert_1.default(this._minuteDecayFactor.lt(1));
      }
      /** @internal */
      _setRecoveryMode(recoveryMode) {
        return new _Fees(this._baseRateWithoutDecay, this._minuteDecayFactor, this._beta, this._lastFeeOperation, this._timeOfLatestBlock, recoveryMode);
      }
      /**
       * Compare to another instance of `Fees`.
       */
      equals(that) {
        return this._baseRateWithoutDecay.eq(that._baseRateWithoutDecay) && this._minuteDecayFactor.eq(that._minuteDecayFactor) && this._beta.eq(that._beta) && this._lastFeeOperation.getTime() === that._lastFeeOperation.getTime() && this._timeOfLatestBlock.getTime() === that._timeOfLatestBlock.getTime() && this._recoveryMode === that._recoveryMode;
      }
      /** @internal */
      toString() {
        return `{ baseRateWithoutDecay: ${this._baseRateWithoutDecay}, lastFeeOperation: "${this._lastFeeOperation.toLocaleString()}", recoveryMode: ${this._recoveryMode} } `;
      }
      /** @internal */
      baseRate(when = this._timeOfLatestBlock) {
        const millisecondsSinceLastFeeOperation = Math.max(
          when.getTime() - this._lastFeeOperation.getTime(),
          0
          // Clamp negative elapsed time to 0, in case the client's time is in the past.
          // We will calculate slightly higher than actual fees, which is fine.
        );
        const minutesSinceLastFeeOperation = Math.floor(millisecondsSinceLastFeeOperation / 6e4);
        return this._minuteDecayFactor.pow(minutesSinceLastFeeOperation).mul(this._baseRateWithoutDecay);
      }
      /**
       * Calculate the current borrowing rate.
       *
       * @param when - Optional timestamp that can be used to calculate what the borrowing rate would
       *               decay to at a point of time in the future.
       *
       * @remarks
       * By default, the fee is calculated at the time of the latest block. This can be overridden using
       * the `when` parameter.
       *
       * To calculate the borrowing fee in LUSD, multiply the borrowed LUSD amount by the borrowing rate.
       *
       * @example
       * ```typescript
       * const fees = await liquity.getFees();
       *
       * const borrowedLUSDAmount = 100;
       * const borrowingRate = fees.borrowingRate();
       * const borrowingFeeLUSD = borrowingRate.mul(borrowedLUSDAmount);
       * ```
       */
      borrowingRate(when) {
        return this._recoveryMode ? Decimal_1.Decimal.ZERO : Decimal_1.Decimal.min(constants_1.MINIMUM_BORROWING_RATE.add(this.baseRate(when)), constants_1.MAXIMUM_BORROWING_RATE);
      }
      /**
         * Calculate the current redemption rate.
         *
         * @param redeemedFractionOfSupply - The amount of LUSD being redeemed divided by the total supply.
         * @param when - Optional timestamp that can be used to calculate what the redemption rate would
         *               decay to at a point of time in the future.
         *
         * @remarks
         * By default, the fee is calculated at the time of the latest block. This can be overridden using
         * the `when` parameter.
      
         * Unlike the borrowing rate, the redemption rate depends on the amount being redeemed. To be more
         * precise, it depends on the fraction of the redeemed amount compared to the total LUSD supply,
         * which must be passed as a parameter.
         *
         * To calculate the redemption fee in LUSD, multiply the redeemed LUSD amount with the redemption
         * rate.
         *
         * @example
         * ```typescript
         * const fees = await liquity.getFees();
         * const total = await liquity.getTotal();
         *
         * const redeemedLUSDAmount = Decimal.from(100);
         * const redeemedFractionOfSupply = redeemedLUSDAmount.div(total.debt);
         * const redemptionRate = fees.redemptionRate(redeemedFractionOfSupply);
         * const redemptionFeeLUSD = redemptionRate.mul(redeemedLUSDAmount);
         * ```
         */
      redemptionRate(redeemedFractionOfSupply = Decimal_1.Decimal.ZERO, when) {
        redeemedFractionOfSupply = Decimal_1.Decimal.from(redeemedFractionOfSupply);
        let baseRate = this.baseRate(when);
        if (redeemedFractionOfSupply.nonZero) {
          baseRate = redeemedFractionOfSupply.div(this._beta).add(baseRate);
        }
        return Decimal_1.Decimal.min(constants_1.MINIMUM_REDEMPTION_RATE.add(baseRate), Decimal_1.Decimal.ONE);
      }
    };
    exports.Fees = Fees;
  }
});

// ../lib-base/dist/src/ReadableLiquity.js
var require_ReadableLiquity = __commonJS({
  "../lib-base/dist/src/ReadableLiquity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../lib-base/dist/src/ObservableLiquity.js
var require_ObservableLiquity = __commonJS({
  "../lib-base/dist/src/ObservableLiquity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../lib-base/dist/src/TransactableLiquity.js
var require_TransactableLiquity = __commonJS({
  "../lib-base/dist/src/TransactableLiquity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionFailedError = void 0;
    var TransactionFailedError = class extends Error {
      /** @internal */
      constructor(name, message, failedReceipt) {
        super(message);
        this.name = name;
        this.failedReceipt = failedReceipt;
      }
    };
    exports.TransactionFailedError = TransactionFailedError;
  }
});

// ../lib-base/dist/src/SendableLiquity.js
var require_SendableLiquity = __commonJS({
  "../lib-base/dist/src/SendableLiquity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._successfulReceipt = exports._failedReceipt = exports._pendingReceipt = void 0;
    exports._pendingReceipt = { status: "pending" };
    var _failedReceipt = (rawReceipt) => ({
      status: "failed",
      rawReceipt
    });
    exports._failedReceipt = _failedReceipt;
    var _successfulReceipt = (rawReceipt, details, toString) => ({
      status: "succeeded",
      rawReceipt,
      details,
      ...toString ? { toString } : {}
    });
    exports._successfulReceipt = _successfulReceipt;
  }
});

// ../lib-base/dist/src/PopulatableLiquity.js
var require_PopulatableLiquity = __commonJS({
  "../lib-base/dist/src/PopulatableLiquity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../lib-base/dist/src/LiquityStore.js
var require_LiquityStore = __commonJS({
  "../lib-base/dist/src/LiquityStore.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LiquityStore = void 0;
    var assert_1 = __importDefault(require_assert());
    var strictEquals = (a, b) => a === b;
    var eq = (a, b) => a.eq(b);
    var equals = (a, b) => a.equals(b);
    var frontendStatusEquals = (a, b) => a.status === "unregistered" ? b.status === "unregistered" : b.status === "registered" && a.kickbackRate.eq(b.kickbackRate);
    var showFrontendStatus = (x) => x.status === "unregistered" ? '{ status: "unregistered" }' : `{ status: "registered", kickbackRate: ${x.kickbackRate} }`;
    var wrap = (f) => (...args) => f(...args);
    var difference = (a, b) => Object.fromEntries(Object.entries(a).filter(([key, value]) => value !== b[key]));
    var LiquityStore = class {
      constructor() {
        this.logging = false;
        this._loaded = false;
        this._listeners = /* @__PURE__ */ new Set();
      }
      /**
       * The current store state.
       *
       * @remarks
       * Should not be accessed before the store is loaded. Assign a function to
       * {@link LiquityStore.onLoaded | onLoaded} to get a callback when this happens.
       *
       * See {@link LiquityStoreState} for the list of properties returned.
       */
      get state() {
        return Object.assign({}, this._baseState, this._derivedState, this._extraState);
      }
      /**
       * Start monitoring the blockchain for Liquity state changes.
       *
       * @remarks
       * The {@link LiquityStore.onLoaded | onLoaded} callback will be called after the state is fetched
       * for the first time.
       *
       * Use the {@link LiquityStore.subscribe | subscribe()} function to register listeners.
       *
       * @returns Function to stop the monitoring.
       */
      start() {
        const doStop = this._doStart();
        return () => {
          doStop();
          this._cancelUpdateIfScheduled();
        };
      }
      _cancelUpdateIfScheduled() {
        if (this._updateTimeoutId !== void 0) {
          clearTimeout(this._updateTimeoutId);
        }
      }
      _scheduleUpdate() {
        this._cancelUpdateIfScheduled();
        this._updateTimeoutId = setTimeout(() => {
          this._updateTimeoutId = void 0;
          this._update();
        }, 3e4);
      }
      _logUpdate(name, next, show) {
        if (this.logging) {
          console.log(`${name} updated to ${show ? show(next) : next}`);
        }
        return next;
      }
      _updateIfChanged(equals2, name, prev, next, show) {
        return next !== void 0 && !equals2(prev, next) ? this._logUpdate(name, next, show) : prev;
      }
      _silentlyUpdateIfChanged(equals2, prev, next) {
        return next !== void 0 && !equals2(prev, next) ? next : prev;
      }
      _updateFees(name, prev, next) {
        if (next && !next.equals(prev)) {
          if (`${next}` !== `${prev}`) {
            this._logUpdate(name, next);
          }
          return next;
        } else {
          return prev;
        }
      }
      _reduce(baseState, baseStateUpdate) {
        return {
          frontend: this._updateIfChanged(frontendStatusEquals, "frontend", baseState.frontend, baseStateUpdate.frontend, showFrontendStatus),
          ownFrontend: this._updateIfChanged(frontendStatusEquals, "ownFrontend", baseState.ownFrontend, baseStateUpdate.ownFrontend, showFrontendStatus),
          numberOfTroves: this._updateIfChanged(strictEquals, "numberOfTroves", baseState.numberOfTroves, baseStateUpdate.numberOfTroves),
          accountBalance: this._updateIfChanged(eq, "accountBalance", baseState.accountBalance, baseStateUpdate.accountBalance),
          lusdBalance: this._updateIfChanged(eq, "lusdBalance", baseState.lusdBalance, baseStateUpdate.lusdBalance),
          lqtyBalance: this._updateIfChanged(eq, "lqtyBalance", baseState.lqtyBalance, baseStateUpdate.lqtyBalance),
          uniTokenBalance: this._updateIfChanged(eq, "uniTokenBalance", baseState.uniTokenBalance, baseStateUpdate.uniTokenBalance),
          uniTokenAllowance: this._updateIfChanged(eq, "uniTokenAllowance", baseState.uniTokenAllowance, baseStateUpdate.uniTokenAllowance),
          remainingLiquidityMiningLQTYReward: this._silentlyUpdateIfChanged(eq, baseState.remainingLiquidityMiningLQTYReward, baseStateUpdate.remainingLiquidityMiningLQTYReward),
          liquidityMiningStake: this._updateIfChanged(eq, "liquidityMiningStake", baseState.liquidityMiningStake, baseStateUpdate.liquidityMiningStake),
          totalStakedUniTokens: this._updateIfChanged(eq, "totalStakedUniTokens", baseState.totalStakedUniTokens, baseStateUpdate.totalStakedUniTokens),
          liquidityMiningLQTYReward: this._silentlyUpdateIfChanged(eq, baseState.liquidityMiningLQTYReward, baseStateUpdate.liquidityMiningLQTYReward),
          collateralSurplusBalance: this._updateIfChanged(eq, "collateralSurplusBalance", baseState.collateralSurplusBalance, baseStateUpdate.collateralSurplusBalance),
          price: this._updateIfChanged(eq, "price", baseState.price, baseStateUpdate.price),
          lusdInStabilityPool: this._updateIfChanged(eq, "lusdInStabilityPool", baseState.lusdInStabilityPool, baseStateUpdate.lusdInStabilityPool),
          total: this._updateIfChanged(equals, "total", baseState.total, baseStateUpdate.total),
          totalRedistributed: this._updateIfChanged(equals, "totalRedistributed", baseState.totalRedistributed, baseStateUpdate.totalRedistributed),
          troveBeforeRedistribution: this._updateIfChanged(equals, "troveBeforeRedistribution", baseState.troveBeforeRedistribution, baseStateUpdate.troveBeforeRedistribution),
          stabilityDeposit: this._updateIfChanged(equals, "stabilityDeposit", baseState.stabilityDeposit, baseStateUpdate.stabilityDeposit),
          remainingStabilityPoolLQTYReward: this._silentlyUpdateIfChanged(eq, baseState.remainingStabilityPoolLQTYReward, baseStateUpdate.remainingStabilityPoolLQTYReward),
          _feesInNormalMode: this._silentlyUpdateIfChanged(equals, baseState._feesInNormalMode, baseStateUpdate._feesInNormalMode),
          lqtyStake: this._updateIfChanged(equals, "lqtyStake", baseState.lqtyStake, baseStateUpdate.lqtyStake),
          totalStakedLQTY: this._updateIfChanged(eq, "totalStakedLQTY", baseState.totalStakedLQTY, baseStateUpdate.totalStakedLQTY),
          _riskiestTroveBeforeRedistribution: this._silentlyUpdateIfChanged(equals, baseState._riskiestTroveBeforeRedistribution, baseStateUpdate._riskiestTroveBeforeRedistribution)
        };
      }
      _derive({ troveBeforeRedistribution, totalRedistributed, _feesInNormalMode, total, price, _riskiestTroveBeforeRedistribution }) {
        const fees = _feesInNormalMode._setRecoveryMode(total.collateralRatioIsBelowCritical(price));
        return {
          trove: troveBeforeRedistribution.applyRedistribution(totalRedistributed),
          fees,
          borrowingRate: fees.borrowingRate(),
          redemptionRate: fees.redemptionRate(),
          haveUndercollateralizedTroves: _riskiestTroveBeforeRedistribution.applyRedistribution(totalRedistributed).collateralRatioIsBelowMinimum(price)
        };
      }
      _reduceDerived(derivedState, derivedStateUpdate) {
        return {
          fees: this._updateFees("fees", derivedState.fees, derivedStateUpdate.fees),
          trove: this._updateIfChanged(equals, "trove", derivedState.trove, derivedStateUpdate.trove),
          borrowingRate: this._silentlyUpdateIfChanged(eq, derivedState.borrowingRate, derivedStateUpdate.borrowingRate),
          redemptionRate: this._silentlyUpdateIfChanged(eq, derivedState.redemptionRate, derivedStateUpdate.redemptionRate),
          haveUndercollateralizedTroves: this._updateIfChanged(strictEquals, "haveUndercollateralizedTroves", derivedState.haveUndercollateralizedTroves, derivedStateUpdate.haveUndercollateralizedTroves)
        };
      }
      _notify(params) {
        [...this._listeners].forEach((listener) => {
          if (this._listeners.has(listener)) {
            listener(params);
          }
        });
      }
      /**
       * Register a state change listener.
       *
       * @param listener - Function that will be called whenever state changes.
       * @returns Function to unregister this listener.
       */
      subscribe(listener) {
        const uniqueListener = wrap(listener);
        this._listeners.add(uniqueListener);
        return () => {
          this._listeners.delete(uniqueListener);
        };
      }
      /** @internal */
      _load(baseState, extraState) {
        assert_1.default(!this._loaded);
        this._baseState = baseState;
        this._derivedState = this._derive(baseState);
        this._extraState = extraState;
        this._loaded = true;
        this._scheduleUpdate();
        if (this.onLoaded) {
          this.onLoaded();
        }
      }
      /** @internal */
      _update(baseStateUpdate, extraStateUpdate) {
        assert_1.default(this._baseState && this._derivedState);
        const oldState = this.state;
        if (baseStateUpdate) {
          this._baseState = this._reduce(this._baseState, baseStateUpdate);
        }
        this._derivedState = this._reduceDerived(this._derivedState, this._derive(this._baseState));
        if (extraStateUpdate) {
          assert_1.default(this._extraState);
          this._extraState = this._reduceExtra(this._extraState, extraStateUpdate);
        }
        this._scheduleUpdate();
        this._notify({
          newState: this.state,
          oldState,
          stateChange: difference(this.state, oldState)
        });
      }
    };
    exports.LiquityStore = LiquityStore;
  }
});

// ../lib-base/dist/src/_CachedReadableLiquity.js
var require_CachedReadableLiquity = __commonJS({
  "../lib-base/dist/src/_CachedReadableLiquity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._CachedReadableLiquity = void 0;
    var _CachedReadableLiquity = class {
      constructor(readable, cache) {
        this._readable = readable;
        this._cache = cache;
      }
      async getTotalRedistributed(...extraParams) {
        var _a;
        return (_a = this._cache.getTotalRedistributed(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getTotalRedistributed(...extraParams);
      }
      async getTroveBeforeRedistribution(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getTroveBeforeRedistribution(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getTroveBeforeRedistribution(address, ...extraParams);
      }
      async getTrove(address, ...extraParams) {
        const [troveBeforeRedistribution, totalRedistributed] = await Promise.all([
          this.getTroveBeforeRedistribution(address, ...extraParams),
          this.getTotalRedistributed(...extraParams)
        ]);
        return troveBeforeRedistribution.applyRedistribution(totalRedistributed);
      }
      async getNumberOfTroves(...extraParams) {
        var _a;
        return (_a = this._cache.getNumberOfTroves(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getNumberOfTroves(...extraParams);
      }
      async getPrice(...extraParams) {
        var _a;
        return (_a = this._cache.getPrice(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getPrice(...extraParams);
      }
      async getTotal(...extraParams) {
        var _a;
        return (_a = this._cache.getTotal(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getTotal(...extraParams);
      }
      async getStabilityDeposit(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getStabilityDeposit(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getStabilityDeposit(address, ...extraParams);
      }
      async getRemainingStabilityPoolLQTYReward(...extraParams) {
        var _a;
        return (_a = this._cache.getRemainingStabilityPoolLQTYReward(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getRemainingStabilityPoolLQTYReward(...extraParams);
      }
      async getLUSDInStabilityPool(...extraParams) {
        var _a;
        return (_a = this._cache.getLUSDInStabilityPool(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getLUSDInStabilityPool(...extraParams);
      }
      async getLUSDBalance(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getLUSDBalance(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getLUSDBalance(address, ...extraParams);
      }
      async getLQTYBalance(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getLQTYBalance(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getLQTYBalance(address, ...extraParams);
      }
      async getUniTokenBalance(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getUniTokenBalance(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getUniTokenBalance(address, ...extraParams);
      }
      async getUniTokenAllowance(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getUniTokenAllowance(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getUniTokenAllowance(address, ...extraParams);
      }
      async getRemainingLiquidityMiningLQTYReward(...extraParams) {
        var _a;
        return (_a = this._cache.getRemainingLiquidityMiningLQTYReward(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getRemainingLiquidityMiningLQTYReward(...extraParams);
      }
      async getLiquidityMiningStake(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getLiquidityMiningStake(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getLiquidityMiningStake(address, ...extraParams);
      }
      async getTotalStakedUniTokens(...extraParams) {
        var _a;
        return (_a = this._cache.getTotalStakedUniTokens(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getTotalStakedUniTokens(...extraParams);
      }
      async getLiquidityMiningLQTYReward(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getLiquidityMiningLQTYReward(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getLiquidityMiningLQTYReward(address, ...extraParams);
      }
      async getCollateralSurplusBalance(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getCollateralSurplusBalance(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getCollateralSurplusBalance(address, ...extraParams);
      }
      async getTroves(params, ...extraParams) {
        var _a;
        const { beforeRedistribution, ...restOfParams } = params;
        const [totalRedistributed, troves] = await Promise.all([
          beforeRedistribution ? void 0 : this.getTotalRedistributed(...extraParams),
          (_a = this._cache.getTroves({ beforeRedistribution: true, ...restOfParams }, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getTroves({ beforeRedistribution: true, ...restOfParams }, ...extraParams)
        ]);
        if (totalRedistributed) {
          return troves.map((trove) => trove.applyRedistribution(totalRedistributed));
        } else {
          return troves;
        }
      }
      async getFees(...extraParams) {
        var _a;
        return (_a = this._cache.getFees(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getFees(...extraParams);
      }
      async getLQTYStake(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getLQTYStake(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getLQTYStake(address, ...extraParams);
      }
      async getTotalStakedLQTY(...extraParams) {
        var _a;
        return (_a = this._cache.getTotalStakedLQTY(...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getTotalStakedLQTY(...extraParams);
      }
      async getFrontendStatus(address, ...extraParams) {
        var _a;
        return (_a = this._cache.getFrontendStatus(address, ...extraParams)) !== null && _a !== void 0 ? _a : this._readable.getFrontendStatus(address, ...extraParams);
      }
    };
    exports._CachedReadableLiquity = _CachedReadableLiquity;
  }
});

// ../lib-base/dist/index.js
var require_dist = __commonJS({
  "../lib-base/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_constants(), exports);
    __exportStar(require_Decimal(), exports);
    __exportStar(require_Trove(), exports);
    __exportStar(require_StabilityDeposit(), exports);
    __exportStar(require_LQTYStake(), exports);
    __exportStar(require_Fees(), exports);
    __exportStar(require_ReadableLiquity(), exports);
    __exportStar(require_ObservableLiquity(), exports);
    __exportStar(require_TransactableLiquity(), exports);
    __exportStar(require_SendableLiquity(), exports);
    __exportStar(require_PopulatableLiquity(), exports);
    __exportStar(require_LiquityStore(), exports);
    __exportStar(require_CachedReadableLiquity(), exports);
  }
});

export {
  require_assert,
  require_dist
};
//# sourceMappingURL=chunk-PHAN2QNE.js.map
