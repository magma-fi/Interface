{
  "version": 3,
  "sources": ["../../../../providers/src/WebSocketProvider.ts", "../../../../providers/src/WebSocketAugmentedProvider.ts", "../../../../providers/src/BatchedProvider.ts", "../../../../providers/index.ts"],
  "sourcesContent": ["import { WebSocketProvider as EthersWebSocketProvider } from \"@ethersproject/providers\";\n\nexport class WebSocketProvider extends EthersWebSocketProvider {\n  get isReady() {\n    return (this._websocket as WebSocket).readyState === WebSocket.OPEN;\n  }\n\n  set onClose(closeListener: ((closeEvent: CloseEvent) => void) | null) {\n    (this._websocket as WebSocket).onclose = closeListener;\n  }\n\n  close(code?: number) {\n    (this._websocket as WebSocket).close(code);\n  }\n\n  async detectNetwork() {\n    return this.network;\n  }\n}\n", "import {\n  TransactionRequest,\n  TransactionReceipt,\n  TransactionResponse,\n  BlockTag,\n  EventType,\n  Listener,\n  Provider,\n  Block\n} from \"@ethersproject/abstract-provider\";\nimport { BaseProvider, Web3Provider } from \"@ethersproject/providers\";\nimport { Networkish } from \"@ethersproject/networks\";\nimport { Deferrable } from \"@ethersproject/properties\";\nimport { hexDataLength } from \"@ethersproject/bytes\";\n\nimport { WebSocketProvider } from \"./WebSocketProvider\";\n\nexport interface WebSocketAugmentedProvider extends BaseProvider {\n  openWebSocket(url: string, network: Networkish): void;\n  closeWebSocket(): void;\n}\n\nconst webSocketAugmentedProviders: any[] = [];\n\nexport const isWebSocketAugmentedProvider = (\n  provider: Provider\n): provider is WebSocketAugmentedProvider =>\n  webSocketAugmentedProviders.some(\n    webSocketAugmentedProvider => provider instanceof webSocketAugmentedProvider\n  );\n\nconst isHeaderNotFoundError = (error: any) =>\n  typeof error === \"object\" &&\n  typeof error.message === \"string\" &&\n  (error.message.includes(\n    // geth\n    \"header not found\"\n  ) ||\n    error.message.includes(\n      // openethereum\n      \"request is not supported because your node is running with state pruning\"\n    ));\n\nconst isTransactionHash = (eventName: EventType): eventName is string =>\n  typeof eventName === \"string\" && hexDataLength(eventName) === 32;\n\nconst loadBalancingGlitchRetryIntervalMs = 200;\nconst delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\ntype BlockListenerContext = {\n  isActive: () => boolean;\n  removeMe: () => void;\n};\n\nconst waitFor = <T, U>(f: (t: T) => Promise<U | null>) => (g: (u: U) => void) => (\n  t: T,\n  { isActive }: BlockListenerContext\n) => {\n  f(t).then(u => {\n    if (u !== null && isActive()) {\n      g(u);\n    }\n  });\n};\n\nconst pass = <T>(f: (t: T) => void) => (t: T, _: BlockListenerContext) => {\n  f(t);\n};\n\nconst passOnce = <T>(f: (t: T) => void) => (t: T, { removeMe }: BlockListenerContext) => {\n  f(t);\n  removeMe();\n};\n\nconst sequence = <T, U, V>(\n  f: (_: (_: U) => void) => (_: T, context: BlockListenerContext) => void,\n  g: (_: (_: V) => void) => (_: U, context: BlockListenerContext) => void\n) => (h: (_: V) => void) => (t: T, context: BlockListenerContext) => {\n  f(u => g(h)(u, context))(t, context);\n};\n\nconst defer = <T>(f: (t: T) => void) => (t: T) => {\n  setTimeout(() => {\n    f(t);\n  }, 0);\n};\n\nexport const WebSocketAugmented = <T extends new (...args: any[]) => BaseProvider>(Base: T) => {\n  let webSocketAugmentedProvider = class extends Base implements WebSocketAugmentedProvider {\n    _wsProvider?: WebSocketProvider;\n    _wsParams?: [string, Networkish];\n    _reconnectTimerId: any;\n\n    _seenBlock = 0;\n    _blockListenerScheduled = false;\n\n    readonly _blockListeners = new Map<(_: never) => void, (blockNumber: number) => void>();\n    readonly _blockListener = this._onBlock.bind(this);\n\n    openWebSocket(url: string, network: Networkish) {\n      this._wsProvider = new WebSocketProvider(url, network);\n      this._wsProvider.onClose = this._onWebSocketClose.bind(this);\n      this._wsParams = [url, network];\n      this._switchover();\n    }\n\n    _onWebSocketClose() {\n      this.closeWebSocket();\n      console.warn(\"WebSocketProvider disconnected. Retrying in 10 seconds.\");\n      this._reconnectTimerId = setTimeout(() => this.openWebSocket(...this._wsParams!), 10000);\n    }\n\n    closeWebSocket() {\n      if (this._wsProvider) {\n        this._wsProvider.onClose = null;\n        this._wsProvider.close(1000); // normal closure\n        this._wsProvider = undefined;\n        this._switchover();\n\n        if (this._reconnectTimerId !== undefined) {\n          clearTimeout(this._reconnectTimerId);\n          this._reconnectTimerId = undefined;\n        }\n      }\n    }\n\n    _switchover() {\n      if (this._blockListeners.size > 0) {\n        if (this._wsProvider) {\n          super.off(\"block\", this._blockListener);\n        }\n        this._startBlockEvents();\n      }\n    }\n\n    _onBlock(blockNumber: number) {\n      this._seenBlock = blockNumber;\n\n      if (!this._blockListenerScheduled) {\n        this._blockListenerScheduled = true;\n\n        setTimeout(() => {\n          this._blockListenerScheduled = false;\n          [...this._blockListeners].forEach(([, listener]) => listener(this._seenBlock));\n        }, 50);\n      }\n    }\n\n    async _retrySeenBlock<T>(perform: () => Promise<T>, startingBlock: number) {\n      for (let retries = 0; ; ++retries) {\n        try {\n          const ret = await perform();\n          if (retries) {\n            // console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n          }\n          return ret;\n        } catch (error) {\n          if (this._seenBlock !== startingBlock || !isHeaderNotFoundError(error)) {\n            throw error;\n          }\n        }\n\n        // console.warn(\"Load balancing glitch. Retrying...\");\n        await delay(loadBalancingGlitchRetryIntervalMs);\n      }\n    }\n\n    async call(\n      transaction: Deferrable<TransactionRequest>,\n      blockTag?: BlockTag | Promise<BlockTag>\n    ) {\n      const resolvedBlockTag = await blockTag;\n\n      const perform = () =>\n        this._wsProvider?.isReady\n          ? this._wsProvider.call(transaction, resolvedBlockTag)\n          : super.call(transaction, resolvedBlockTag);\n\n      return resolvedBlockTag === this._seenBlock\n        ? this._retrySeenBlock(perform, this._seenBlock)\n        : perform();\n    }\n\n    async getBalance(\n      addressOrName: string | Promise<string>,\n      blockTag?: BlockTag | Promise<BlockTag>\n    ) {\n      const resolvedBlockTag = await blockTag;\n\n      const perform = () =>\n        this._wsProvider?.isReady\n          ? this._wsProvider.getBalance(addressOrName, resolvedBlockTag)\n          : super.getBalance(addressOrName, resolvedBlockTag);\n\n      return resolvedBlockTag === this._seenBlock\n        ? this._retrySeenBlock(perform, this._seenBlock)\n        : perform();\n    }\n\n    _startBlockEvents() {\n      if (this._wsProvider) {\n        console.log(\"Listening for new blocks on WebSocketProvider\");\n        this._wsProvider.on(\"block\", this._blockListener);\n      } else {\n        console.log(\"Listening for new blocks on basic Provider\");\n        super.on(\"block\", this._blockListener);\n      }\n    }\n\n    _stopBlockEvents() {\n      if (this._wsProvider) {\n        this._wsProvider.off(\"block\", this._blockListener);\n      } else {\n        super.off(\"block\", this._blockListener);\n      }\n    }\n\n    _wrap<T, U>(\n      f: (t: T) => void,\n      g: (f: (t: T) => void) => (u: U, { removeMe }: BlockListenerContext) => void\n    ): [(t: T) => void, (u: U) => void] {\n      return [\n        f,\n        (u: U) =>\n          g(defer(f))(u, {\n            isActive: () => this._blockListeners.has(f),\n            removeMe: () => this._blockListeners.delete(f)\n          })\n      ];\n    }\n\n    on(eventName: EventType, listener: Listener) {\n      if (isTransactionHash(eventName)) {\n        const fetchReceipt = this._getTransactionReceiptFromLatest.bind(this, eventName);\n        const [, passReceipt] = this._wrap(listener, waitFor(fetchReceipt));\n\n        passReceipt(undefined);\n\n        return this._addBlockListener(listener, passReceipt);\n      } else if (eventName === \"block\") {\n        return this._addBlockListener(...this._wrap(listener, pass));\n      } else {\n        return super.on(eventName, listener);\n      }\n    }\n\n    _addBlockListener(key: (_: never) => void, blockListener: (blockNumber: number) => void) {\n      if (!this._blockListeners.has(key)) {\n        this._blockListeners.set(key, blockListener);\n\n        if (this._blockListeners.size === 1) {\n          this._startBlockEvents();\n        }\n      }\n      return this;\n    }\n\n    once(eventName: EventType, listener: Listener) {\n      if (isTransactionHash(eventName)) {\n        const fetchReceipt = this._getTransactionReceiptFromLatest.bind(this, eventName);\n        const [, passReceiptOnce] = this._wrap(listener, sequence(waitFor(fetchReceipt), passOnce));\n\n        passReceiptOnce(undefined);\n\n        return this._addBlockListener(listener, passReceiptOnce);\n      } else if (eventName === \"block\") {\n        return this._addBlockListener(...this._wrap(listener, passOnce));\n      } else {\n        return super.once(eventName, listener);\n      }\n    }\n\n    off(eventName: EventType, listener: Listener) {\n      if (isTransactionHash(eventName) || eventName === \"block\") {\n        return this._removeBlockListener(listener);\n      } else {\n        return super.off(eventName, listener);\n      }\n    }\n\n    _removeBlockListener(key: (_: never) => void) {\n      if (this._blockListeners.has(key)) {\n        this._blockListeners.delete(key);\n        if (this._blockListeners.size === 0) {\n          this._stopBlockEvents();\n        }\n      }\n      return this;\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>) {\n      const txPromises: Promise<TransactionResponse | null>[] = [\n        super.getTransaction(transactionHash),\n        ...(this._wsProvider?.isReady ? [this._wsProvider.getTransaction(transactionHash)] : [])\n      ];\n\n      const first = await Promise.race(txPromises);\n      const tx = first ?? (await Promise.all(txPromises)).find(tx => tx !== null) ?? null;\n\n      return tx as TransactionResponse;\n    }\n\n    getTransactionReceipt(transactionHash: string | Promise<string>) {\n      return this._wsProvider?.isReady\n        ? this._wsProvider.getTransactionReceipt(transactionHash)\n        : super.getTransactionReceipt(transactionHash);\n    }\n\n    getTransactionCount(\n      addressOrName: string | Promise<string>,\n      blockTag?: BlockTag | Promise<BlockTag>\n    ) {\n      return this._wsProvider?.isReady\n        ? this._wsProvider.getTransactionCount(addressOrName, blockTag)\n        : super.getTransactionCount(addressOrName, blockTag);\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>) {\n      return this._wsProvider?.isReady\n        ? this._wsProvider.getBlock(blockHashOrBlockTag)\n        : super.getBlock(blockHashOrBlockTag);\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>) {\n      return this._wsProvider?.isReady\n        ? this._wsProvider.getBlockWithTransactions(blockHashOrBlockTag)\n        : super.getBlockWithTransactions(blockHashOrBlockTag);\n    }\n\n    async _blockContainsTx(blockNumber: number, txHash: string) {\n      let block: Block | null;\n\n      for (block = null; !block; block = await this.getBlock(blockNumber)) {\n        await delay(loadBalancingGlitchRetryIntervalMs);\n      }\n\n      return block.transactions.some(txHashInBlock => txHashInBlock === txHash);\n    }\n\n    async _getTransactionReceiptFromLatest(txHash: string | Promise<string>, latestBlock?: number) {\n      txHash = await txHash;\n\n      for (let retries = 0; ; ++retries) {\n        const receipt = (await this.getTransactionReceipt(txHash)) as TransactionReceipt | null;\n\n        if (\n          latestBlock === undefined ||\n          (receipt === null && !(await this._blockContainsTx(latestBlock, txHash))) ||\n          (receipt !== null && receipt.blockNumber + receipt.confirmations - 1 >= latestBlock)\n        ) {\n          if (retries) {\n            // console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n          }\n          return receipt;\n        }\n\n        // console.warn(\"Load balancing glitch. Retrying...\");\n        await delay(loadBalancingGlitchRetryIntervalMs);\n      }\n    }\n\n    async waitForTransaction(txHash: string, confirmations?: number, timeout?: number) {\n      if (timeout !== undefined) {\n        // We don't use timeout, don't implement it\n        return super.waitForTransaction(txHash, confirmations, timeout);\n      }\n\n      let latestBlock: number | undefined = undefined;\n      for (;;) {\n        const receipt = await this._getTransactionReceiptFromLatest(txHash, latestBlock);\n\n        if (\n          receipt !== null &&\n          (confirmations === undefined || receipt.confirmations >= confirmations)\n        ) {\n          return receipt;\n        }\n\n        latestBlock = await new Promise<number>(resolve => this.once(\"block\", resolve));\n      }\n    }\n  };\n\n  webSocketAugmentedProviders.push(webSocketAugmentedProvider);\n\n  return webSocketAugmentedProvider;\n};\n\nexport const WebSocketAugmentedWeb3Provider = WebSocketAugmented(Web3Provider);\n", "import { isAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Provider, TransactionRequest, BlockTag } from \"@ethersproject/abstract-provider\";\nimport { BaseProvider } from \"@ethersproject/providers\";\nimport { BytesLike } from \"@ethersproject/bytes\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { Deferrable, resolveProperties } from \"@ethersproject/properties\";\n\nimport { WebSocketAugmentedWeb3Provider } from \"./WebSocketAugmentedProvider\";\n\nconst multicallAddress = {\n  1: \"0xeefBa1e63905eF1D7ACbA5a8513c70307C1cE441\",\n  3: \"0x53C43764255c17BD724F74c4eF150724AC50a3ed\",\n  4: \"0x42Ad527de7d4e9d9d011aC45B31D8551f8Fe9821\",\n  5: \"0x77dCa2C955b15e9dE4dbBCf1246B4B85b651e50e\",\n  42: \"0x2cc8688C5f75E365aaEEb4ea8D6a480405A48D2A\"\n};\n\nconst hasMulticall = (chainId: number): chainId is keyof typeof multicallAddress =>\n  chainId in multicallAddress;\n\nconst multicallAbi = [\n  {\n    type: \"function\",\n    name: \"aggregate\",\n    stateMutability: \"nonpayable\",\n    constant: false,\n    payable: false,\n\n    inputs: [\n      {\n        components: [\n          {\n            name: \"target\",\n            type: \"address\"\n          },\n          {\n            name: \"callData\",\n            type: \"bytes\"\n          }\n        ],\n        name: \"calls\",\n        type: \"tuple[]\"\n      }\n    ],\n\n    outputs: [\n      {\n        name: \"blockNumber\",\n        type: \"uint256\"\n      },\n      {\n        name: \"returnData\",\n        type: \"bytes[]\"\n      }\n    ]\n  },\n\n  {\n    type: \"function\",\n    name: \"getEthBalance\",\n    stateMutability: \"view\",\n    constant: true,\n    payable: false,\n\n    inputs: [\n      {\n        name: \"addr\",\n        type: \"address\"\n      }\n    ],\n\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"uint256\"\n      }\n    ]\n  }\n];\n\ntype CallRequest = {\n  target: string;\n  callData: BytesLike;\n};\n\ntype BatchableOverrides = { blockTag?: BlockTag };\n\ninterface Multicall extends Contract {\n  readonly callStatic: {\n    aggregate(\n      calls: CallRequest[],\n      overrides?: BatchableOverrides\n    ): Promise<{ blockNumber: BigNumber; returnData: string[] }>;\n  };\n\n  readonly functions: {\n    getEthBalance(addr: string, overrides?: BatchableOverrides): Promise<[BigNumber]>;\n  };\n}\n\ntype ResolvedTransactionRequest = {\n  to?: string;\n  from?: string;\n  nonce?: BigNumberish;\n  gasLimit?: BigNumberish;\n  gasPrice?: BigNumberish;\n  data?: BytesLike;\n  value?: BigNumberish;\n  chainId?: number;\n};\n\ninterface BatchedCalls extends BatchableOverrides {\n  calls: CallRequest[];\n  callbacks: [(resolveValue: string) => void, (rejectReason: any) => void][];\n}\n\nconst emptyBatch = (): BatchedCalls => ({ calls: [], callbacks: [] });\n\n// TODO\n//\n// Technically, requests that have a `from` address shouldn't be batched, because `msg.sender` will\n// be replaced with the Multicall contract's address when the batched calls are being executed.\n//\n// Currently, `@liquity/lib-ethers` makes many of its read calls through Signers, which populates\n// `from`. Instead these calls should be made through a Provider, and `from` should be omitted\n// (since none of the read calls in Liquity care about `msg.sender`).\n//\n// Then we'll be able to properly exclude calls that have `from` addresses from batching.\nconst batchableCall = (request: ResolvedTransactionRequest) =>\n  request.gasLimit === undefined && request.gasPrice === undefined && request.value === undefined;\n\nconst batchedCall = (request: ResolvedTransactionRequest, multicallAddress: string) =>\n  request.to === multicallAddress &&\n  typeof request.data === \"string\" &&\n  request.data.startsWith(\"0x252dba42\"); // signature of `aggregate((address,bytes)[])`\n\nexport interface BatchedProvider extends BaseProvider {\n  batchingDelayMs: number;\n  chainId: number;\n}\n\nconst batchedProviders: any[] = [];\n\nexport const isBatchedProvider = (provider: Provider): provider is BatchedProvider =>\n  batchedProviders.some(batchedProvider => provider instanceof batchedProvider);\n\nexport const Batched = <T extends new (...args: any[]) => BaseProvider>(Base: T) => {\n  const batchedProvider = class extends Base implements BatchedProvider {\n    batchingDelayMs = 10;\n\n    _chainId = 0;\n    _multicall?: Multicall;\n    _timeoutId: any;\n    _batched: BatchedCalls = emptyBatch();\n\n    _numberOfBatchedCalls = 0;\n    _numberOfActualCalls = 0;\n    _timeOfLastRatioCheck?: number;\n\n    get chainId() {\n      return this._chainId;\n    }\n\n    set chainId(chainId: number) {\n      if (this._multicall) {\n        throw new Error(\"can only set chainId once\");\n      }\n\n      if (hasMulticall(chainId)) {\n        this._multicall = new Contract(multicallAddress[chainId], multicallAbi, this) as Multicall;\n      }\n\n      this._chainId = chainId;\n    }\n\n    async _dispatchCalls() {\n      const { calls, callbacks, blockTag } = this._batched;\n      this._batched = emptyBatch();\n\n      try {\n        const results =\n          calls.length > 1\n            ? await this._multicall!.callStatic.aggregate(calls, { blockTag }).then(\n                x => x.returnData\n              )\n            : [await super.call({ to: calls[0].target, data: calls[0].callData }, blockTag)];\n\n        callbacks.forEach(([resolve], i) => resolve(results[i]));\n      } catch (error) {\n        callbacks.forEach(([, reject]) => reject(error));\n      }\n    }\n\n    _enqueueCall(call: CallRequest): Promise<string> {\n      if (this._timeoutId !== undefined) {\n        clearTimeout(this._timeoutId);\n      }\n\n      this._batched.calls.push(call);\n      this._timeoutId = setTimeout(() => this._dispatchCalls(), this.batchingDelayMs);\n\n      return new Promise((resolve, reject) => this._batched.callbacks.push([resolve, reject]));\n    }\n\n    _alreadyBatchedCallsConflictWith(blockTag?: BlockTag) {\n      return (\n        this._batched.calls.length !== 0 &&\n        (blockTag ?? \"latest\") !== (this._batched.blockTag ?? \"latest\")\n      );\n    }\n\n    async call(\n      request: Deferrable<TransactionRequest>,\n      blockTag?: BlockTag | Promise<BlockTag>\n    ): Promise<string> {\n      if (!this._multicall) {\n        return super.call(request, blockTag);\n      } else {\n        const now = new Date().getTime();\n\n        if (this._timeOfLastRatioCheck === undefined) {\n          this._timeOfLastRatioCheck = now;\n        } else {\n          const timeSinceLastRatioCheck = now - this._timeOfLastRatioCheck;\n\n          if (timeSinceLastRatioCheck >= 10000 && this._numberOfActualCalls) {\n            // console.log(\n            //   `Call batching ratio: ${\n            //     Math.round((10 * this._numberOfBatchedCalls) / this._numberOfActualCalls) / 10\n            //   }X`\n            // );\n\n            this._numberOfBatchedCalls = 0;\n            this._numberOfActualCalls = 0;\n            this._timeOfLastRatioCheck = now;\n          }\n        }\n      }\n\n      const [resolvedRequest, resolvedBlockTag] = await Promise.all([\n        resolveProperties(request),\n        blockTag\n      ]);\n\n      if (\n        batchedCall(resolvedRequest, this._multicall.address) ||\n        !batchableCall(resolvedRequest) ||\n        this._alreadyBatchedCallsConflictWith(resolvedBlockTag)\n      ) {\n        this._numberOfActualCalls++;\n\n        return super.call(resolvedRequest, resolvedBlockTag);\n      } else {\n        this._numberOfBatchedCalls++;\n\n        if (this._batched.calls.length === 0) {\n          this._batched.blockTag = resolvedBlockTag;\n        }\n\n        return this._enqueueCall({ target: resolvedRequest.to!, callData: resolvedRequest.data! });\n      }\n    }\n\n    async getBalance(\n      addressOrName: string | Promise<string>,\n      blockTag?: BlockTag | Promise<BlockTag>\n    ): Promise<BigNumber> {\n      const [resolvedAddressOrName, resolvedBlockTag] = await Promise.all([addressOrName, blockTag]);\n\n      if (!isAddress(resolvedAddressOrName) || !this._multicall) {\n        return super.getBalance(resolvedAddressOrName, blockTag);\n      }\n\n      const [balance] = await this._multicall.functions.getEthBalance(resolvedAddressOrName, {\n        blockTag: resolvedBlockTag\n      });\n\n      return balance;\n    }\n  };\n\n  batchedProviders.push(batchedProvider);\n\n  return batchedProvider;\n};\n\nexport const BatchedWebSocketAugmentedWeb3Provider = Batched(WebSocketAugmentedWeb3Provider);\n", "export * from \"./src/BatchedProvider\";\nexport * from \"./src/WebSocketAugmentedProvider\";\nexport * from \"./src/WebSocketProvider\";\n"],
  "mappings": "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",
  "names": ["tx", "multicallAddress"]
}
