import {
  require_hash
} from "./chunk-T52DPOSF.js";
import {
  defineReadOnly,
  init_lib as init_lib3
} from "./chunk-NX6UMJZK.js";
import {
  arrayify,
  init_lib as init_lib2
} from "./chunk-GMRHNXBP.js";
import {
  Logger,
  init_lib
} from "./chunk-ILADNUF6.js";
import {
  __esm,
  __export,
  __toESM
} from "./chunk-W7S2ME4R.js";

// ../../node_modules/@ethersproject/random/lib.esm/_version.js
var version;
var init_version = __esm({
  "../../node_modules/@ethersproject/random/lib.esm/_version.js"() {
    version = "random/5.7.0";
  }
});

// ../../node_modules/@ethersproject/random/lib.esm/random.js
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  throw new Error("unable to locate global object");
}
function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto.getRandomValues(result);
  return arrayify(result);
}
var logger, anyGlobal, crypto;
var init_random = __esm({
  "../../node_modules/@ethersproject/random/lib.esm/random.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version();
    logger = new Logger(version);
    anyGlobal = getGlobal();
    crypto = anyGlobal.crypto || anyGlobal.msCrypto;
    if (!crypto || !crypto.getRandomValues) {
      logger.warn("WARNING: Missing strong random number source");
      crypto = {
        getRandomValues: function(buffer) {
          return logger.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
          });
        }
      };
    }
  }
});

// ../../node_modules/@ethersproject/random/lib.esm/shuffle.js
function shuffled(array) {
  array = array.slice();
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
  return array;
}
var init_shuffle = __esm({
  "../../node_modules/@ethersproject/random/lib.esm/shuffle.js"() {
    "use strict";
  }
});

// ../../node_modules/@ethersproject/random/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  randomBytes: () => randomBytes,
  shuffled: () => shuffled
});
var init_lib4 = __esm({
  "../../node_modules/@ethersproject/random/lib.esm/index.js"() {
    "use strict";
    init_random();
    init_shuffle();
  }
});

// ../../node_modules/@ethersproject/basex/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  Base32: () => Base32,
  Base58: () => Base58,
  BaseX: () => BaseX
});
var BaseX, Base32, Base58;
var init_lib5 = __esm({
  "../../node_modules/@ethersproject/basex/lib.esm/index.js"() {
    init_lib2();
    init_lib3();
    BaseX = class {
      constructor(alphabet) {
        defineReadOnly(this, "alphabet", alphabet);
        defineReadOnly(this, "base", alphabet.length);
        defineReadOnly(this, "_alphabetMap", {});
        defineReadOnly(this, "_leader", alphabet.charAt(0));
        for (let i = 0; i < alphabet.length; i++) {
          this._alphabetMap[alphabet.charAt(i)] = i;
        }
      }
      encode(value) {
        let source = arrayify(value);
        if (source.length === 0) {
          return "";
        }
        let digits = [0];
        for (let i = 0; i < source.length; ++i) {
          let carry = source[i];
          for (let j = 0; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % this.base;
            carry = carry / this.base | 0;
          }
          while (carry > 0) {
            digits.push(carry % this.base);
            carry = carry / this.base | 0;
          }
        }
        let string = "";
        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
          string += this._leader;
        }
        for (let q = digits.length - 1; q >= 0; --q) {
          string += this.alphabet[digits[q]];
        }
        return string;
      }
      decode(value) {
        if (typeof value !== "string") {
          throw new TypeError("Expected String");
        }
        let bytes = [];
        if (value.length === 0) {
          return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (let i = 0; i < value.length; i++) {
          let byte = this._alphabetMap[value[i]];
          if (byte === void 0) {
            throw new Error("Non-base" + this.base + " character");
          }
          let carry = byte;
          for (let j = 0; j < bytes.length; ++j) {
            carry += bytes[j] * this.base;
            bytes[j] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 255);
            carry >>= 8;
          }
        }
        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
          bytes.push(0);
        }
        return arrayify(new Uint8Array(bytes.reverse()));
      }
    };
    Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
    Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  }
});

// ../../node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
var init_types = __esm({
  "../../node_modules/@ethersproject/sha2/lib.esm/types.js"() {
    (function(SupportedAlgorithm2) {
      SupportedAlgorithm2["sha256"] = "sha256";
      SupportedAlgorithm2["sha512"] = "sha512";
    })(SupportedAlgorithm || (SupportedAlgorithm = {}));
  }
});

// ../../node_modules/@ethersproject/sha2/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "../../node_modules/@ethersproject/sha2/lib.esm/_version.js"() {
    version2 = "sha2/5.7.0";
  }
});

// ../../node_modules/@ethersproject/sha2/lib.esm/sha2.js
function ripemd160(data) {
  return "0x" + import_hash.default.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256(data) {
  return "0x" + import_hash.default.sha256().update(arrayify(data)).digest("hex");
}
function sha512(data) {
  return "0x" + import_hash.default.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm, key, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger2.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash.default.hmac(import_hash.default[algorithm], arrayify(key)).update(arrayify(data)).digest("hex");
}
var import_hash, logger2;
var init_sha2 = __esm({
  "../../node_modules/@ethersproject/sha2/lib.esm/sha2.js"() {
    "use strict";
    import_hash = __toESM(require_hash());
    init_lib2();
    init_types();
    init_lib();
    init_version2();
    logger2 = new Logger(version2);
  }
});

// ../../node_modules/@ethersproject/sha2/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  SupportedAlgorithm: () => SupportedAlgorithm,
  computeHmac: () => computeHmac,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});
var init_lib6 = __esm({
  "../../node_modules/@ethersproject/sha2/lib.esm/index.js"() {
    init_sha2();
    init_types();
  }
});

export {
  Base58,
  lib_exports2 as lib_exports,
  init_lib5 as init_lib,
  SupportedAlgorithm,
  ripemd160,
  sha256,
  sha512,
  computeHmac,
  lib_exports3 as lib_exports2,
  init_lib6 as init_lib2,
  randomBytes,
  shuffled,
  lib_exports as lib_exports3,
  init_lib4 as init_lib3
};
//# sourceMappingURL=chunk-7IGKFX3U.js.map
