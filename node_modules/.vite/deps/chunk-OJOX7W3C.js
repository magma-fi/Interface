import {
  Description,
  defineReadOnly,
  init_lib as init_lib4,
  resolveProperties
} from "./chunk-NX6UMJZK.js";
import {
  BigNumber,
  init_lib as init_lib3
} from "./chunk-WJIB2CDQ.js";
import {
  init_lib as init_lib2,
  isHexString
} from "./chunk-GMRHNXBP.js";
import {
  Logger,
  init_lib
} from "./chunk-ILADNUF6.js";
import {
  __esm
} from "./chunk-W7S2ME4R.js";

// ../../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version;
var init_version = __esm({
  "../../node_modules/@ethersproject/abstract-provider/lib.esm/_version.js"() {
    version = "abstract-provider/5.7.0";
  }
});

// ../../node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter, logger, ForkEvent, BlockForkEvent, TransactionForkEvent, TransactionOrderForkEvent, Provider;
var init_lib5 = __esm({
  "../../node_modules/@ethersproject/abstract-provider/lib.esm/index.js"() {
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib();
    init_version();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger = new Logger(version);
    ForkEvent = class extends Description {
      static isForkEvent(value) {
        return !!(value && value._isForkEvent);
      }
    };
    BlockForkEvent = class extends ForkEvent {
      constructor(blockHash, expiry) {
        if (!isHexString(blockHash, 32)) {
          logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
        }
        super({
          _isForkEvent: true,
          _isBlockForkEvent: true,
          expiry: expiry || 0,
          blockHash
        });
      }
    };
    TransactionForkEvent = class extends ForkEvent {
      constructor(hash, expiry) {
        if (!isHexString(hash, 32)) {
          logger.throwArgumentError("invalid transaction hash", "hash", hash);
        }
        super({
          _isForkEvent: true,
          _isTransactionForkEvent: true,
          expiry: expiry || 0,
          hash
        });
      }
    };
    TransactionOrderForkEvent = class extends ForkEvent {
      constructor(beforeHash, afterHash, expiry) {
        if (!isHexString(beforeHash, 32)) {
          logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
        }
        if (!isHexString(afterHash, 32)) {
          logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
        }
        super({
          _isForkEvent: true,
          _isTransactionOrderForkEvent: true,
          expiry: expiry || 0,
          beforeHash,
          afterHash
        });
      }
    };
    Provider = class _Provider {
      constructor() {
        logger.checkAbstract(new.target, _Provider);
        defineReadOnly(this, "_isProvider", true);
      }
      getFeeData() {
        return __awaiter(this, void 0, void 0, function* () {
          const { block, gasPrice } = yield resolveProperties({
            block: this.getBlock("latest"),
            gasPrice: this.getGasPrice().catch((error) => {
              return null;
            })
          });
          let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
          if (block && block.baseFeePerGas) {
            lastBaseFeePerGas = block.baseFeePerGas;
            maxPriorityFeePerGas = BigNumber.from("1500000000");
            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
          }
          return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
      }
      // Alias for "on"
      addListener(eventName, listener) {
        return this.on(eventName, listener);
      }
      // Alias for "off"
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
      static isProvider(value) {
        return !!(value && value._isProvider);
      }
    };
  }
});

export {
  ForkEvent,
  BlockForkEvent,
  TransactionForkEvent,
  TransactionOrderForkEvent,
  Provider,
  init_lib5 as init_lib
};
//# sourceMappingURL=chunk-OJOX7W3C.js.map
