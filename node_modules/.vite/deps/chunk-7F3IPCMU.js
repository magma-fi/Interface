import {
  Signer,
  VoidSigner,
  accessListify,
  init_lib as init_lib8,
  init_lib3 as init_lib9
} from "./chunk-T52DPOSF.js";
import {
  Provider,
  init_lib as init_lib7
} from "./chunk-OJOX7W3C.js";
import {
  Indexed,
  Interface,
  checkResultErrors,
  init_lib as init_lib6
} from "./chunk-D4XBSYTF.js";
import {
  deepCopy,
  defineReadOnly,
  getStatic,
  init_lib as init_lib5,
  resolveProperties,
  shallowCopy
} from "./chunk-NX6UMJZK.js";
import {
  getAddress,
  getContractAddress,
  init_lib3 as init_lib4
} from "./chunk-HWCAXKAJ.js";
import {
  BigNumber,
  init_lib as init_lib3
} from "./chunk-WJIB2CDQ.js";
import {
  arrayify,
  concat,
  hexlify,
  init_lib as init_lib2,
  isBytes,
  isHexString
} from "./chunk-GMRHNXBP.js";
import {
  Logger,
  init_lib
} from "./chunk-ILADNUF6.js";
import {
  __esm,
  __export
} from "./chunk-W7S2ME4R.js";

// ../../node_modules/@ethersproject/contracts/lib.esm/_version.js
var version;
var init_version = __esm({
  "../../node_modules/@ethersproject/contracts/lib.esm/_version.js"() {
    version = "contracts/5.7.0";
  }
});

// ../../node_modules/@ethersproject/contracts/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  BaseContract: () => BaseContract,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory
});
function resolveName(resolver, nameOrPromise) {
  return __awaiter(this, void 0, void 0, function* () {
    const name = yield nameOrPromise;
    if (typeof name !== "string") {
      logger.throwArgumentError("invalid address or ENS name", "name", name);
    }
    try {
      return getAddress(name);
    } catch (error) {
    }
    if (!resolver) {
      logger.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name);
    if (address == null) {
      logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data);
      for (let i = 0; i < bytes.length; i++) {
        intrinsic += 4;
        if (bytes[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key) => overrides[key] != null);
    if (leftovers.length) {
      logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var __awaiter, logger, allowedTransactionKeys, RunningEvent, ErrorRunningEvent, FragmentRunningEvent, WildcardRunningEvent, BaseContract, Contract, ContractFactory;
var init_lib10 = __esm({
  "../../node_modules/@ethersproject/contracts/lib.esm/index.js"() {
    init_lib6();
    init_lib7();
    init_lib8();
    init_lib4();
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib9();
    init_lib();
    init_version();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger = new Logger(version);
    allowedTransactionKeys = {
      chainId: true,
      data: true,
      from: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true,
      customData: true,
      ccipReadEnabled: true
    };
    RunningEvent = class {
      constructor(tag, filter) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "filter", filter);
        this._listeners = [];
      }
      addListener(listener, once) {
        this._listeners.push({ listener, once });
      }
      removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
          if (done || item.listener !== listener) {
            return true;
          }
          done = true;
          return false;
        });
      }
      removeAllListeners() {
        this._listeners = [];
      }
      listeners() {
        return this._listeners.map((i) => i.listener);
      }
      listenerCount() {
        return this._listeners.length;
      }
      run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
          const argsCopy = args.slice();
          setTimeout(() => {
            item.listener.apply(this, argsCopy);
          }, 0);
          return !item.once;
        });
        return listenerCount;
      }
      prepareEvent(event) {
      }
      // Returns the array that will be applied to an emit
      getEmit(event) {
        return [event];
      }
    };
    ErrorRunningEvent = class extends RunningEvent {
      constructor() {
        super("error", null);
      }
    };
    FragmentRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface, fragment, topics) {
        const filter = {
          address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
          if (topic !== topics[0]) {
            logger.throwArgumentError("topic mismatch", "topics", topics);
          }
          filter.topics = topics.slice();
        } else {
          filter.topics = [topic];
        }
        super(getEventTag(filter), filter);
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
        defineReadOnly(this, "fragment", fragment);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics) => {
          return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
          event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        } catch (error) {
          event.args = null;
          event.decodeError = error;
        }
      }
      getEmit(event) {
        const errors = checkResultErrors(event.args);
        if (errors.length) {
          throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
      }
    };
    WildcardRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface) {
        super("*", { address });
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        try {
          const parsed = this.interface.parseLog(event);
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
          event.decode = (data, topics) => {
            return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.args = parsed.args;
        } catch (error) {
        }
      }
    };
    BaseContract = class {
      constructor(addressOrName, contractInterface, signerOrProvider) {
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
          defineReadOnly(this, "provider", null);
          defineReadOnly(this, "signer", null);
        } else if (Signer.isSigner(signerOrProvider)) {
          defineReadOnly(this, "provider", signerOrProvider.provider || null);
          defineReadOnly(this, "signer", signerOrProvider);
        } else if (Provider.isProvider(signerOrProvider)) {
          defineReadOnly(this, "provider", signerOrProvider);
          defineReadOnly(this, "signer", null);
        } else {
          logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        defineReadOnly(this, "callStatic", {});
        defineReadOnly(this, "estimateGas", {});
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "populateTransaction", {});
        defineReadOnly(this, "filters", {});
        {
          const uniqueFilters = {};
          Object.keys(this.interface.events).forEach((eventSignature) => {
            const event = this.interface.events[eventSignature];
            defineReadOnly(this.filters, eventSignature, (...args) => {
              return {
                address: this.address,
                topics: this.interface.encodeFilterTopics(event, args)
              };
            });
            if (!uniqueFilters[event.name]) {
              uniqueFilters[event.name] = [];
            }
            uniqueFilters[event.name].push(eventSignature);
          });
          Object.keys(uniqueFilters).forEach((name) => {
            const filters = uniqueFilters[name];
            if (filters.length === 1) {
              defineReadOnly(this.filters, name, this.filters[filters[0]]);
            } else {
              logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
            }
          });
        }
        defineReadOnly(this, "_runningEvents", {});
        defineReadOnly(this, "_wrappedEmits", {});
        if (addressOrName == null) {
          logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        defineReadOnly(this, "address", addressOrName);
        if (this.provider) {
          defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        } else {
          try {
            defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
          } catch (error) {
            logger.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new Contract"
            });
          }
        }
        this.resolvedAddress.catch((e) => {
        });
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature) => {
          const fragment = this.interface.functions[signature];
          if (uniqueSignatures[signature]) {
            logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
            return;
          }
          uniqueSignatures[signature] = true;
          {
            const name = fragment.name;
            if (!uniqueNames[`%${name}`]) {
              uniqueNames[`%${name}`] = [];
            }
            uniqueNames[`%${name}`].push(signature);
          }
          if (this[signature] == null) {
            defineReadOnly(this, signature, buildDefault(this, fragment, true));
          }
          if (this.functions[signature] == null) {
            defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));
          }
          if (this.callStatic[signature] == null) {
            defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));
          }
          if (this.populateTransaction[signature] == null) {
            defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));
          }
          if (this.estimateGas[signature] == null) {
            defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));
          }
        });
        Object.keys(uniqueNames).forEach((name) => {
          const signatures = uniqueNames[name];
          if (signatures.length > 1) {
            return;
          }
          name = name.substring(1);
          const signature = signatures[0];
          try {
            if (this[name] == null) {
              defineReadOnly(this, name, this[signature]);
            }
          } catch (e) {
          }
          if (this.functions[name] == null) {
            defineReadOnly(this.functions, name, this.functions[signature]);
          }
          if (this.callStatic[name] == null) {
            defineReadOnly(this.callStatic, name, this.callStatic[signature]);
          }
          if (this.populateTransaction[name] == null) {
            defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);
          }
          if (this.estimateGas[name] == null) {
            defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);
          }
        });
      }
      static getContractAddress(transaction) {
        return getContractAddress(transaction);
      }
      static getInterface(contractInterface) {
        if (Interface.isInterface(contractInterface)) {
          return contractInterface;
        }
        return new Interface(contractInterface);
      }
      // @TODO: Allow timeout?
      deployed() {
        return this._deployed();
      }
      _deployed(blockTag) {
        if (!this._deployedPromise) {
          if (this.deployTransaction) {
            this._deployedPromise = this.deployTransaction.wait().then(() => {
              return this;
            });
          } else {
            this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
              if (code === "0x") {
                logger.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                  contractAddress: this.address,
                  operation: "getDeployed"
                });
              }
              return this;
            });
          }
        }
        return this._deployedPromise;
      }
      // @TODO:
      // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
      // @TODO:
      // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
      fallback(overrides) {
        if (!this.signer) {
          logger.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = shallowCopy(overrides || {});
        ["from", "to"].forEach(function(key) {
          if (tx[key] == null) {
            return;
          }
          logger.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
          return this.signer.sendTransaction(tx);
        });
      }
      // Reconnect to a different signer or provider
      connect(signerOrProvider) {
        if (typeof signerOrProvider === "string") {
          signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
        }
        const contract = new this.constructor(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
          defineReadOnly(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
      }
      // Re-attach to a different on-chain instance of this contract
      attach(addressOrName) {
        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
      }
      static isIndexed(value) {
        return Indexed.isIndexed(value);
      }
      _normalizeRunningEvent(runningEvent) {
        if (this._runningEvents[runningEvent.tag]) {
          return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
      }
      _getRunningEvent(eventName) {
        if (typeof eventName === "string") {
          if (eventName === "error") {
            return this._normalizeRunningEvent(new ErrorRunningEvent());
          }
          if (eventName === "event") {
            return this._normalizeRunningEvent(new RunningEvent("event", null));
          }
          if (eventName === "*") {
            return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
          }
          const fragment = this.interface.getEvent(eventName);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        if (eventName.topics && eventName.topics.length > 0) {
          try {
            const topic = eventName.topics[0];
            if (typeof topic !== "string") {
              throw new Error("invalid topic");
            }
            const fragment = this.interface.getEvent(topic);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
          } catch (error) {
          }
          const filter = {
            address: this.address,
            topics: eventName.topics
          };
          return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
          delete this._runningEvents[runningEvent.tag];
          const emit = this._wrappedEmits[runningEvent.tag];
          if (emit && runningEvent.filter) {
            this.provider.off(runningEvent.filter, emit);
            delete this._wrappedEmits[runningEvent.tag];
          }
        }
      }
      // Subclasses can override this to gracefully recover
      // from parse errors if they wish
      _wrapEvent(runningEvent, log, listener) {
        const event = deepCopy(log);
        event.removeListener = () => {
          if (!listener) {
            return;
          }
          runningEvent.removeListener(listener);
          this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => {
          return this.provider.getBlock(log.blockHash);
        };
        event.getTransaction = () => {
          return this.provider.getTransaction(log.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return this.provider.getTransactionReceipt(log.transactionHash);
        };
        runningEvent.prepareEvent(event);
        return event;
      }
      _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
          logger.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        this._runningEvents[runningEvent.tag] = runningEvent;
        if (!this._wrappedEmits[runningEvent.tag]) {
          const wrappedEmit = (log) => {
            let event = this._wrapEvent(runningEvent, log, listener);
            if (event.decodeError == null) {
              try {
                const args = runningEvent.getEmit(event);
                this.emit(runningEvent.filter, ...args);
              } catch (error) {
                event.decodeError = error.error;
              }
            }
            if (runningEvent.filter != null) {
              this.emit("event", event);
            }
            if (event.decodeError != null) {
              this.emit("error", event.decodeError, event);
            }
          };
          this._wrappedEmits[runningEvent.tag] = wrappedEmit;
          if (runningEvent.filter != null) {
            this.provider.on(runningEvent.filter, wrappedEmit);
          }
        }
      }
      queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = shallowCopy(runningEvent.filter);
        if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
          if (toBlock != null) {
            logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
          }
          filter.blockHash = fromBlockOrBlockhash;
        } else {
          filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
          filter.toBlock = toBlock != null ? toBlock : "latest";
        }
        return this.provider.getLogs(filter).then((logs) => {
          return logs.map((log) => this._wrapEvent(runningEvent, log, null));
        });
      }
      on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
      }
      once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
      }
      emit(eventName, ...args) {
        if (!this.provider) {
          return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = runningEvent.run(args) > 0;
        this._checkRunningEvents(runningEvent);
        return result;
      }
      listenerCount(eventName) {
        if (!this.provider) {
          return 0;
        }
        if (eventName == null) {
          return Object.keys(this._runningEvents).reduce((accum, key) => {
            return accum + this._runningEvents[key].listenerCount();
          }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
      }
      listeners(eventName) {
        if (!this.provider) {
          return [];
        }
        if (eventName == null) {
          const result = [];
          for (let tag in this._runningEvents) {
            this._runningEvents[tag].listeners().forEach((listener) => {
              result.push(listener);
            });
          }
          return result;
        }
        return this._getRunningEvent(eventName).listeners();
      }
      removeAllListeners(eventName) {
        if (!this.provider) {
          return this;
        }
        if (eventName == null) {
          for (const tag in this._runningEvents) {
            const runningEvent2 = this._runningEvents[tag];
            runningEvent2.removeAllListeners();
            this._checkRunningEvents(runningEvent2);
          }
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
      }
      off(eventName, listener) {
        if (!this.provider) {
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
      }
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
    };
    Contract = class extends BaseContract {
    };
    ContractFactory = class {
      constructor(contractInterface, bytecode, signer) {
        let bytecodeHex = null;
        if (typeof bytecode === "string") {
          bytecodeHex = bytecode;
        } else if (isBytes(bytecode)) {
          bytecodeHex = hexlify(bytecode);
        } else if (bytecode && typeof bytecode.object === "string") {
          bytecodeHex = bytecode.object;
        } else {
          bytecodeHex = "!";
        }
        if (bytecodeHex.substring(0, 2) !== "0x") {
          bytecodeHex = "0x" + bytecodeHex;
        }
        if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
          logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        }
        if (signer && !Signer.isSigner(signer)) {
          logger.throwArgumentError("invalid signer", "signer", signer);
        }
        defineReadOnly(this, "bytecode", bytecodeHex);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        defineReadOnly(this, "signer", signer || null);
      }
      // @TODO: Future; rename to populateTransaction?
      getDeployTransaction(...args) {
        let tx = {};
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          tx = shallowCopy(args.pop());
          for (const key in tx) {
            if (!allowedTransactionKeys[key]) {
              throw new Error("unknown transaction override " + key);
            }
          }
        }
        ["data", "from", "to"].forEach((key) => {
          if (tx[key] == null) {
            return;
          }
          logger.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        if (tx.value) {
          const value = BigNumber.from(tx.value);
          if (!value.isZero() && !this.interface.deploy.payable) {
            logger.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.value",
              value: tx.value
            });
          }
        }
        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        tx.data = hexlify(concat([
          this.bytecode,
          this.interface.encodeDeploy(args)
        ]));
        return tx;
      }
      deploy(...args) {
        return __awaiter(this, void 0, void 0, function* () {
          let overrides = {};
          if (args.length === this.interface.deploy.inputs.length + 1) {
            overrides = args.pop();
          }
          logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
          const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
          params.push(overrides);
          const unsignedTx = this.getDeployTransaction(...params);
          const tx = yield this.signer.sendTransaction(unsignedTx);
          const address = getStatic(this.constructor, "getContractAddress")(tx);
          const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
          addContractWait(contract, tx);
          defineReadOnly(contract, "deployTransaction", tx);
          return contract;
        });
      }
      attach(address) {
        return this.constructor.getContract(address, this.interface, this.signer);
      }
      connect(signer) {
        return new this.constructor(this.interface, this.bytecode, signer);
      }
      static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) {
          logger.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
        }
        if (typeof compilerOutput === "string") {
          compilerOutput = JSON.parse(compilerOutput);
        }
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) {
          bytecode = compilerOutput.bytecode;
        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
          bytecode = compilerOutput.evm.bytecode;
        }
        return new this(abi, bytecode, signer);
      }
      static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
      }
      static getContractAddress(tx) {
        return getContractAddress(tx);
      }
      static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
      }
    };
  }
});

export {
  BaseContract,
  Contract,
  ContractFactory,
  lib_exports,
  init_lib10 as init_lib
};
//# sourceMappingURL=chunk-7F3IPCMU.js.map
