import {
  init_lib as init_lib4,
  lib_exports as lib_exports4
} from "./chunk-7F3IPCMU.js";
import {
  init_lib2 as init_lib5,
  lib_exports2 as lib_exports5
} from "./chunk-5IOYYMYR.js";
import "./chunk-ZWLQA6XW.js";
import "./chunk-7IGKFX3U.js";
import "./chunk-T52DPOSF.js";
import "./chunk-XHZS53IJ.js";
import "./chunk-OJOX7W3C.js";
import "./chunk-D4XBSYTF.js";
import "./chunk-OEYWMA6Q.js";
import {
  init_lib as init_lib3,
  lib_exports as lib_exports3
} from "./chunk-NX6UMJZK.js";
import "./chunk-PPBSEKDQ.js";
import {
  init_lib3 as init_lib2,
  lib_exports3 as lib_exports2
} from "./chunk-HWCAXKAJ.js";
import "./chunk-WJIB2CDQ.js";
import "./chunk-5OUNQ6TZ.js";
import "./chunk-YV7UKSM3.js";
import "./chunk-5AVNCSA7.js";
import {
  init_lib,
  lib_exports
} from "./chunk-GMRHNXBP.js";
import "./chunk-ILADNUF6.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-W7S2ME4R.js";

// ../providers/dist/src/WebSocketProvider.js
var require_WebSocketProvider = __commonJS({
  "../providers/dist/src/WebSocketProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketProvider = void 0;
    var providers_1 = (init_lib5(), __toCommonJS(lib_exports5));
    var WebSocketProvider = class extends providers_1.WebSocketProvider {
      get isReady() {
        return this._websocket.readyState === WebSocket.OPEN;
      }
      set onClose(closeListener) {
        this._websocket.onclose = closeListener;
      }
      close(code) {
        this._websocket.close(code);
      }
      async detectNetwork() {
        return this.network;
      }
    };
    exports.WebSocketProvider = WebSocketProvider;
  }
});

// ../providers/dist/src/WebSocketAugmentedProvider.js
var require_WebSocketAugmentedProvider = __commonJS({
  "../providers/dist/src/WebSocketAugmentedProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented = exports.isWebSocketAugmentedProvider = void 0;
    var providers_1 = (init_lib5(), __toCommonJS(lib_exports5));
    var bytes_1 = (init_lib(), __toCommonJS(lib_exports));
    var WebSocketProvider_1 = require_WebSocketProvider();
    var webSocketAugmentedProviders = [];
    var isWebSocketAugmentedProvider = (provider) => webSocketAugmentedProviders.some((webSocketAugmentedProvider) => provider instanceof webSocketAugmentedProvider);
    exports.isWebSocketAugmentedProvider = isWebSocketAugmentedProvider;
    var isHeaderNotFoundError = (error) => typeof error === "object" && typeof error.message === "string" && (error.message.includes(
      // geth
      "header not found"
    ) || error.message.includes(
      // openethereum
      "request is not supported because your node is running with state pruning"
    ));
    var isTransactionHash = (eventName) => typeof eventName === "string" && bytes_1.hexDataLength(eventName) === 32;
    var loadBalancingGlitchRetryIntervalMs = 200;
    var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    var waitFor = (f) => (g) => (t, { isActive }) => {
      f(t).then((u) => {
        if (u !== null && isActive()) {
          g(u);
        }
      });
    };
    var pass = (f) => (t, _) => {
      f(t);
    };
    var passOnce = (f) => (t, { removeMe }) => {
      f(t);
      removeMe();
    };
    var sequence = (f, g) => (h) => (t, context) => {
      f((u) => g(h)(u, context))(t, context);
    };
    var defer = (f) => (t) => {
      setTimeout(() => {
        f(t);
      }, 0);
    };
    var WebSocketAugmented = (Base) => {
      let webSocketAugmentedProvider = class extends Base {
        constructor() {
          super(...arguments);
          this._seenBlock = 0;
          this._blockListenerScheduled = false;
          this._blockListeners = /* @__PURE__ */ new Map();
          this._blockListener = this._onBlock.bind(this);
        }
        openWebSocket(url, network) {
          this._wsProvider = new WebSocketProvider_1.WebSocketProvider(url, network);
          this._wsProvider.onClose = this._onWebSocketClose.bind(this);
          this._wsParams = [url, network];
          this._switchover();
        }
        _onWebSocketClose() {
          this.closeWebSocket();
          console.warn("WebSocketProvider disconnected. Retrying in 10 seconds.");
          this._reconnectTimerId = setTimeout(() => this.openWebSocket(...this._wsParams), 1e4);
        }
        closeWebSocket() {
          if (this._wsProvider) {
            this._wsProvider.onClose = null;
            this._wsProvider.close(1e3);
            this._wsProvider = void 0;
            this._switchover();
            if (this._reconnectTimerId !== void 0) {
              clearTimeout(this._reconnectTimerId);
              this._reconnectTimerId = void 0;
            }
          }
        }
        _switchover() {
          if (this._blockListeners.size > 0) {
            if (this._wsProvider) {
              super.off("block", this._blockListener);
            }
            this._startBlockEvents();
          }
        }
        _onBlock(blockNumber) {
          this._seenBlock = blockNumber;
          if (!this._blockListenerScheduled) {
            this._blockListenerScheduled = true;
            setTimeout(() => {
              this._blockListenerScheduled = false;
              [...this._blockListeners].forEach(([, listener]) => listener(this._seenBlock));
            }, 50);
          }
        }
        async _retrySeenBlock(perform, startingBlock) {
          for (let retries = 0; ; ++retries) {
            try {
              const ret = await perform();
              if (retries) {
              }
              return ret;
            } catch (error) {
              if (this._seenBlock !== startingBlock || !isHeaderNotFoundError(error)) {
                throw error;
              }
            }
            await delay(loadBalancingGlitchRetryIntervalMs);
          }
        }
        async call(transaction, blockTag) {
          const resolvedBlockTag = await blockTag;
          const perform = () => {
            var _a;
            return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.call(transaction, resolvedBlockTag) : super.call(transaction, resolvedBlockTag);
          };
          return resolvedBlockTag === this._seenBlock ? this._retrySeenBlock(perform, this._seenBlock) : perform();
        }
        async getBalance(addressOrName, blockTag) {
          const resolvedBlockTag = await blockTag;
          const perform = () => {
            var _a;
            return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.getBalance(addressOrName, resolvedBlockTag) : super.getBalance(addressOrName, resolvedBlockTag);
          };
          return resolvedBlockTag === this._seenBlock ? this._retrySeenBlock(perform, this._seenBlock) : perform();
        }
        _startBlockEvents() {
          if (this._wsProvider) {
            console.log("Listening for new blocks on WebSocketProvider");
            this._wsProvider.on("block", this._blockListener);
          } else {
            console.log("Listening for new blocks on basic Provider");
            super.on("block", this._blockListener);
          }
        }
        _stopBlockEvents() {
          if (this._wsProvider) {
            this._wsProvider.off("block", this._blockListener);
          } else {
            super.off("block", this._blockListener);
          }
        }
        _wrap(f, g) {
          return [
            f,
            (u) => g(defer(f))(u, {
              isActive: () => this._blockListeners.has(f),
              removeMe: () => this._blockListeners.delete(f)
            })
          ];
        }
        on(eventName, listener) {
          if (isTransactionHash(eventName)) {
            const fetchReceipt = this._getTransactionReceiptFromLatest.bind(this, eventName);
            const [, passReceipt] = this._wrap(listener, waitFor(fetchReceipt));
            passReceipt(void 0);
            return this._addBlockListener(listener, passReceipt);
          } else if (eventName === "block") {
            return this._addBlockListener(...this._wrap(listener, pass));
          } else {
            return super.on(eventName, listener);
          }
        }
        _addBlockListener(key, blockListener) {
          if (!this._blockListeners.has(key)) {
            this._blockListeners.set(key, blockListener);
            if (this._blockListeners.size === 1) {
              this._startBlockEvents();
            }
          }
          return this;
        }
        once(eventName, listener) {
          if (isTransactionHash(eventName)) {
            const fetchReceipt = this._getTransactionReceiptFromLatest.bind(this, eventName);
            const [, passReceiptOnce] = this._wrap(listener, sequence(waitFor(fetchReceipt), passOnce));
            passReceiptOnce(void 0);
            return this._addBlockListener(listener, passReceiptOnce);
          } else if (eventName === "block") {
            return this._addBlockListener(...this._wrap(listener, passOnce));
          } else {
            return super.once(eventName, listener);
          }
        }
        off(eventName, listener) {
          if (isTransactionHash(eventName) || eventName === "block") {
            return this._removeBlockListener(listener);
          } else {
            return super.off(eventName, listener);
          }
        }
        _removeBlockListener(key) {
          if (this._blockListeners.has(key)) {
            this._blockListeners.delete(key);
            if (this._blockListeners.size === 0) {
              this._stopBlockEvents();
            }
          }
          return this;
        }
        async getTransaction(transactionHash) {
          var _a, _b;
          const txPromises = [
            super.getTransaction(transactionHash),
            ...((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? [this._wsProvider.getTransaction(transactionHash)] : []
          ];
          const first = await Promise.race(txPromises);
          const tx = (_b = first !== null && first !== void 0 ? first : (await Promise.all(txPromises)).find((tx2) => tx2 !== null)) !== null && _b !== void 0 ? _b : null;
          return tx;
        }
        getTransactionReceipt(transactionHash) {
          var _a;
          return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.getTransactionReceipt(transactionHash) : super.getTransactionReceipt(transactionHash);
        }
        getTransactionCount(addressOrName, blockTag) {
          var _a;
          return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.getTransactionCount(addressOrName, blockTag) : super.getTransactionCount(addressOrName, blockTag);
        }
        getBlock(blockHashOrBlockTag) {
          var _a;
          return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.getBlock(blockHashOrBlockTag) : super.getBlock(blockHashOrBlockTag);
        }
        getBlockWithTransactions(blockHashOrBlockTag) {
          var _a;
          return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.getBlockWithTransactions(blockHashOrBlockTag) : super.getBlockWithTransactions(blockHashOrBlockTag);
        }
        async _blockContainsTx(blockNumber, txHash) {
          let block;
          for (block = null; !block; block = await this.getBlock(blockNumber)) {
            await delay(loadBalancingGlitchRetryIntervalMs);
          }
          return block.transactions.some((txHashInBlock) => txHashInBlock === txHash);
        }
        async _getTransactionReceiptFromLatest(txHash, latestBlock) {
          txHash = await txHash;
          for (let retries = 0; ; ++retries) {
            const receipt = await this.getTransactionReceipt(txHash);
            if (latestBlock === void 0 || receipt === null && !await this._blockContainsTx(latestBlock, txHash) || receipt !== null && receipt.blockNumber + receipt.confirmations - 1 >= latestBlock) {
              if (retries) {
              }
              return receipt;
            }
            await delay(loadBalancingGlitchRetryIntervalMs);
          }
        }
        async waitForTransaction(txHash, confirmations, timeout) {
          if (timeout !== void 0) {
            return super.waitForTransaction(txHash, confirmations, timeout);
          }
          let latestBlock = void 0;
          for (; ; ) {
            const receipt = await this._getTransactionReceiptFromLatest(txHash, latestBlock);
            if (receipt !== null && (confirmations === void 0 || receipt.confirmations >= confirmations)) {
              return receipt;
            }
            latestBlock = await new Promise((resolve) => this.once("block", resolve));
          }
        }
      };
      webSocketAugmentedProviders.push(webSocketAugmentedProvider);
      return webSocketAugmentedProvider;
    };
    exports.WebSocketAugmented = WebSocketAugmented;
    exports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented(providers_1.Web3Provider);
  }
});

// ../providers/dist/src/BatchedProvider.js
var require_BatchedProvider = __commonJS({
  "../providers/dist/src/BatchedProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched = exports.isBatchedProvider = void 0;
    var address_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var contracts_1 = (init_lib4(), __toCommonJS(lib_exports4));
    var properties_1 = (init_lib3(), __toCommonJS(lib_exports3));
    var WebSocketAugmentedProvider_1 = require_WebSocketAugmentedProvider();
    var multicallAddress = {
      1: "0xeefBa1e63905eF1D7ACbA5a8513c70307C1cE441",
      3: "0x53C43764255c17BD724F74c4eF150724AC50a3ed",
      4: "0x42Ad527de7d4e9d9d011aC45B31D8551f8Fe9821",
      5: "0x77dCa2C955b15e9dE4dbBCf1246B4B85b651e50e",
      42: "0x2cc8688C5f75E365aaEEb4ea8D6a480405A48D2A"
    };
    var hasMulticall = (chainId) => chainId in multicallAddress;
    var multicallAbi = [
      {
        type: "function",
        name: "aggregate",
        stateMutability: "nonpayable",
        constant: false,
        payable: false,
        inputs: [
          {
            components: [
              {
                name: "target",
                type: "address"
              },
              {
                name: "callData",
                type: "bytes"
              }
            ],
            name: "calls",
            type: "tuple[]"
          }
        ],
        outputs: [
          {
            name: "blockNumber",
            type: "uint256"
          },
          {
            name: "returnData",
            type: "bytes[]"
          }
        ]
      },
      {
        type: "function",
        name: "getEthBalance",
        stateMutability: "view",
        constant: true,
        payable: false,
        inputs: [
          {
            name: "addr",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "balance",
            type: "uint256"
          }
        ]
      }
    ];
    var emptyBatch = () => ({ calls: [], callbacks: [] });
    var batchableCall = (request) => request.gasLimit === void 0 && request.gasPrice === void 0 && request.value === void 0;
    var batchedCall = (request, multicallAddress2) => request.to === multicallAddress2 && typeof request.data === "string" && request.data.startsWith("0x252dba42");
    var batchedProviders = [];
    var isBatchedProvider = (provider) => batchedProviders.some((batchedProvider) => provider instanceof batchedProvider);
    exports.isBatchedProvider = isBatchedProvider;
    var Batched = (Base) => {
      const batchedProvider = class extends Base {
        constructor() {
          super(...arguments);
          this.batchingDelayMs = 10;
          this._chainId = 0;
          this._batched = emptyBatch();
          this._numberOfBatchedCalls = 0;
          this._numberOfActualCalls = 0;
        }
        get chainId() {
          return this._chainId;
        }
        set chainId(chainId) {
          if (this._multicall) {
            throw new Error("can only set chainId once");
          }
          if (hasMulticall(chainId)) {
            this._multicall = new contracts_1.Contract(multicallAddress[chainId], multicallAbi, this);
          }
          this._chainId = chainId;
        }
        async _dispatchCalls() {
          const { calls, callbacks, blockTag } = this._batched;
          this._batched = emptyBatch();
          try {
            const results = calls.length > 1 ? await this._multicall.callStatic.aggregate(calls, { blockTag }).then((x) => x.returnData) : [await super.call({ to: calls[0].target, data: calls[0].callData }, blockTag)];
            callbacks.forEach(([resolve], i) => resolve(results[i]));
          } catch (error) {
            callbacks.forEach(([, reject]) => reject(error));
          }
        }
        _enqueueCall(call) {
          if (this._timeoutId !== void 0) {
            clearTimeout(this._timeoutId);
          }
          this._batched.calls.push(call);
          this._timeoutId = setTimeout(() => this._dispatchCalls(), this.batchingDelayMs);
          return new Promise((resolve, reject) => this._batched.callbacks.push([resolve, reject]));
        }
        _alreadyBatchedCallsConflictWith(blockTag) {
          var _a;
          return this._batched.calls.length !== 0 && (blockTag !== null && blockTag !== void 0 ? blockTag : "latest") !== ((_a = this._batched.blockTag) !== null && _a !== void 0 ? _a : "latest");
        }
        async call(request, blockTag) {
          if (!this._multicall) {
            return super.call(request, blockTag);
          } else {
            const now = (/* @__PURE__ */ new Date()).getTime();
            if (this._timeOfLastRatioCheck === void 0) {
              this._timeOfLastRatioCheck = now;
            } else {
              const timeSinceLastRatioCheck = now - this._timeOfLastRatioCheck;
              if (timeSinceLastRatioCheck >= 1e4 && this._numberOfActualCalls) {
                this._numberOfBatchedCalls = 0;
                this._numberOfActualCalls = 0;
                this._timeOfLastRatioCheck = now;
              }
            }
          }
          const [resolvedRequest, resolvedBlockTag] = await Promise.all([
            properties_1.resolveProperties(request),
            blockTag
          ]);
          if (batchedCall(resolvedRequest, this._multicall.address) || !batchableCall(resolvedRequest) || this._alreadyBatchedCallsConflictWith(resolvedBlockTag)) {
            this._numberOfActualCalls++;
            return super.call(resolvedRequest, resolvedBlockTag);
          } else {
            this._numberOfBatchedCalls++;
            if (this._batched.calls.length === 0) {
              this._batched.blockTag = resolvedBlockTag;
            }
            return this._enqueueCall({ target: resolvedRequest.to, callData: resolvedRequest.data });
          }
        }
        async getBalance(addressOrName, blockTag) {
          const [resolvedAddressOrName, resolvedBlockTag] = await Promise.all([addressOrName, blockTag]);
          if (!address_1.isAddress(resolvedAddressOrName) || !this._multicall) {
            return super.getBalance(resolvedAddressOrName, blockTag);
          }
          const [balance] = await this._multicall.functions.getEthBalance(resolvedAddressOrName, {
            blockTag: resolvedBlockTag
          });
          return balance;
        }
      };
      batchedProviders.push(batchedProvider);
      return batchedProvider;
    };
    exports.Batched = Batched;
    exports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched(WebSocketAugmentedProvider_1.WebSocketAugmentedWeb3Provider);
  }
});

// ../providers/dist/index.js
var require_dist = __commonJS({
  "../providers/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_BatchedProvider(), exports);
    __exportStar(require_WebSocketAugmentedProvider(), exports);
    __exportStar(require_WebSocketProvider(), exports);
  }
});
export default require_dist();
//# sourceMappingURL=@liquity_providers.js.map
