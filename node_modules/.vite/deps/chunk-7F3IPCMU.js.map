{
  "version": 3,
  "sources": ["../../../../../node_modules/@ethersproject/contracts/src.ts/_version.ts", "../../../../../node_modules/@ethersproject/contracts/src.ts/index.ts"],
  "sourcesContent": ["export const version = \"contracts/5.7.0\";\n", "\"use strict\";\n\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\nexport interface Overrides {\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    nonce?: BigNumberish | Promise<BigNumberish>;\n    type?: number;\n    accessList?: AccessListish;\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport interface PayableOverrides extends Overrides {\n    value?: BigNumberish | Promise<BigNumberish>;\n}\n\nexport interface CallOverrides extends PayableOverrides {\n    blockTag?: BlockTag | Promise<BlockTag>;\n    from?: string | Promise<string>;\n}\n\n// @TODO: Better hierarchy with: (in v6)\n//  - abstract-provider:TransactionRequest\n//  - transactions:Transaction\n//  - transaction:UnsignedTransaction\n\nexport interface PopulatedTransaction {\n    to?: string;\n    from?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumber;\n    gasPrice?: BigNumber;\n\n    data?: string;\n    value?: BigNumber;\n    chainId?: number;\n\n    type?: number;\n    accessList?: AccessList;\n\n    maxFeePerGas?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport type EventFilter = {\n    address?: string;\n    topics?: Array<string|Array<string>>;\n};\n\n\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\n\n\n// The (n + 1)th parameter passed to contract event callbacks\nexport interface Event extends Log {\n\n    // The event name\n    event?: string;\n\n    // The event signature\n    eventSignature?: string;\n\n    // The parsed arguments to the event\n    args?: Result;\n\n    // If parsing the arguments failed, this is the error\n    decodeError?: Error;\n\n    // A function that can be used to decode event data and topics\n    decode?: (data: string, topics?: Array<string>) => any;\n\n    // A function that will remove the listener responsible for this event (if any)\n    removeListener: () => void;\n\n    // Get blockchain details about this event's block and transaction\n    getBlock: () => Promise<Block>;\n    getTransaction: () => Promise<TransactionResponse>;\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\n}\n\nexport interface ContractReceipt extends TransactionReceipt {\n    events?: Array<Event>;\n}\n\nexport interface ContractTransaction extends TransactionResponse {\n    wait(confirmations?: number): Promise<ContractReceipt>;\n}\n\n///////////////////////////////\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n}\n\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\n    const name = await nameOrPromise;\n\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    }\n\n    // If it is already an address, just use it (after adding checksum)\n    try {\n        return getAddress(name);\n    } catch (error) { }\n\n    if (!resolver) {\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\"\n        });\n    }\n\n    const address = await resolver.resolveName(name);\n\n    if (address == null) {\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n}\n\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\n    if (Array.isArray(paramType)) {\n        return await Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(\n                resolver,\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\n                paramType\n            );\n        }));\n    }\n\n    if (paramType.type === \"address\") {\n        return await resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n        return await resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                argument: \"value\",\n                value\n            }));\n        }\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n}\n\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\n    // If an extra argument is given, it is overrides\n    let overrides: CallOverrides = { };\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n        overrides = shallowCopy(args.pop());\n    }\n\n    // Make sure the parameter count matches\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\n    // Populate \"from\" override (allow promises)\n    if (contract.signer) {\n        if (overrides.from) {\n            // Contracts with a Signer are from the Signer's frame-of-reference;\n            // but we allow overriding \"from\" if it matches the signer\n            overrides.from = resolveProperties({\n                override: resolveName(contract.signer, overrides.from),\n                signer: contract.signer.getAddress()\n            }).then(async (check) => {\n                if (getAddress(check.signer) !== check.override) {\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"overrides.from\"\n                    });\n                }\n\n                return check.override;\n            });\n\n        } else {\n            overrides.from = contract.signer.getAddress();\n        }\n\n    } else if (overrides.from) {\n        overrides.from = resolveName(contract.provider, overrides.from);\n\n    //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n    }\n\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\n    const resolved = await resolveProperties({\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n        address: contract.resolvedAddress,\n        overrides: (resolveProperties(overrides) || { })\n    });\n\n    // The ABI coded transaction\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx: PopulatedTransaction = {\n      data: data,\n      to: resolved.address\n    };\n\n    // Resolved Overrides\n    const ro = resolved.overrides;\n\n    // Populate simple overrides\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\n    if (ro.from != null) { tx.from = ro.from; }\n\n    if (ro.type != null) { tx.type = ro.type; }\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\n\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n    if (tx.gasLimit == null && fragment.gas != null) {\n        // Compute the intrinsic gas cost for this transaction\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\n        // we may wish to parameterize in v6 as part of the Network object. Since this\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\n        // similar logic to the ContractFactory.\n        let intrinsic = 21000;\n        const bytes = arrayify(data);\n        for (let i = 0; i < bytes.length; i++) {\n            intrinsic += 4;\n            if (bytes[i]) { intrinsic += 64; }\n        }\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    }\n\n    // Populate \"value\" override\n    if (ro.value) {\n        const roValue = BigNumber.from(ro.value);\n        if (!roValue.isZero() && !fragment.payable) {\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides.value\",\n                value: overrides.value\n            });\n        }\n        tx.value = roValue;\n    }\n\n    if (ro.customData) {\n        tx.customData = shallowCopy(ro.customData);\n    }\n\n    if (ro.ccipReadEnabled) {\n        tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n    }\n\n    // Remove the overrides\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n\n    delete overrides.type;\n    delete overrides.accessList;\n\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n\n    delete overrides.customData;\n    delete overrides.ccipReadEnabled;\n\n    // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\n    if (leftovers.length) {\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"overrides\",\n            overrides: leftovers\n        });\n    }\n\n    return tx;\n}\n\n\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\n        return populateTransaction(contract, fragment, args);\n    };\n}\n\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return async function(...args: Array<any>): Promise<BigNumber> {\n        if (!signerOrProvider) {\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"estimateGas\"\n            })\n        }\n\n        const tx = await populateTransaction(contract, fragment, args);\n        return await signerOrProvider.estimateGas(tx);\n    };\n}\n\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations?: number) => {\n        return wait(confirmations).then((receipt: ContractReceipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event: Event = (<Event>deepCopy(log));\n                let parsed: LogDescription = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e){ }\n\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n\n                // Useful operations\n                event.removeListener = () => { return contract.provider; }\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                }\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                }\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                }\n\n                return event;\n            });\n\n            return receipt;\n        });\n    };\n}\n\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    const signerOrProvider = (contract.signer || contract.provider);\n\n    return async function(...args: Array<any>): Promise<any> {\n        // Extract the \"blockTag\" override if present\n        let blockTag = undefined;\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            const overrides = shallowCopy(args.pop());\n            if (overrides.blockTag != null) {\n                blockTag = await overrides.blockTag;\n            }\n            delete overrides.blockTag;\n            args.push(overrides);\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed(blockTag);\n        }\n\n        // Call a node and get the result\n        const tx = await populateTransaction(contract, fragment, args);\n        const result = await signerOrProvider.call(tx, blockTag);\n\n        try {\n            let value = contract.interface.decodeFunctionResult(fragment, result);\n            if (collapseSimple && fragment.outputs.length === 1) {\n                value = value[0];\n            }\n            return value;\n\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n                error.address = contract.address;\n                error.args = args;\n                error.transaction = tx;\n            }\n            throw error;\n         }\n    };\n}\n\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\n        if (!contract.signer) {\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction\"\n            })\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed();\n        }\n\n        const txRequest = await populateTransaction(contract, fragment, args);\n\n        const tx = await contract.signer.sendTransaction(txRequest);\n\n        // Tweak the tx.wait so the receipt has extra properties\n        addContractWait(contract, tx);\n\n        return tx;\n    };\n}\n\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter: EventFilter): string {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\"): \"\");\n}\n\nclass RunningEvent {\n    readonly tag: string;\n    readonly filter: EventFilter;\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\n\n    constructor(tag: string, filter: EventFilter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [ ];\n    }\n\n    addListener(listener: Listener, once: boolean): void {\n        this._listeners.push({ listener: listener, once: once });\n    }\n\n    removeListener(listener: Listener): void {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) { return true; }\n            done = true;\n            return false;\n        });\n    }\n\n    removeAllListeners(): void {\n        this._listeners = [];\n    }\n\n    listeners(): Array<Listener> {\n        return this._listeners.map((i) => i.listener);\n    }\n\n    listenerCount(): number {\n        return this._listeners.length;\n    }\n\n    run(args: Array<any>): number {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n\n            const argsCopy = args.slice();\n\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n\n        return listenerCount;\n    }\n\n    prepareEvent(event: Event): void {\n    }\n\n    // Returns the array that will be applied to an emit\n    getEmit(event: Event): Array<any> {\n        return [ event ];\n    }\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n\n\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n    readonly fragment: EventFragment;\n\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\n        const filter: EventFilter = {\n            address: address\n        }\n\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [ topic ];\n        }\n\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n\n    getEmit(event: Event): Array<any> {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) { throw errors[0].error; }\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n\n    constructor(address: string, contractInterface: Interface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n\n            event.args = parsed.args;\n        } catch (error) {\n            // No matching event\n        }\n    }\n}\n\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\n\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\n\n\nexport class BaseContract {\n    readonly address: string;\n    readonly interface: Interface;\n\n    readonly signer: Signer;\n    readonly provider: Provider;\n\n    readonly functions: { [ name: string ]: ContractFunction };\n\n    readonly callStatic: { [ name: string ]: ContractFunction };\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\n\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\n\n    // This will always be an address. This will only differ from\n    // address if an ENS name was used in the constructor\n    readonly resolvedAddress: Promise<string>;\n\n    // This is only set if the contract was created with a call to deploy\n    readonly deployTransaction: TransactionResponse;\n\n    _deployedPromise: Promise<Contract>;\n\n    // A list of RunningEvents to track listeners for each event tag\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\n\n    // Wrapped functions to call emit and allow deregistration from the provider\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\n\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        } else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        } else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n\n        defineReadOnly(this, \"callStatic\", { });\n        defineReadOnly(this, \"estimateGas\", { });\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"populateTransaction\", { });\n\n        defineReadOnly(this, \"filters\", { });\n\n        {\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                   }\n                });\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\n                }\n            });\n        }\n\n        defineReadOnly(this, \"_runningEvents\", { });\n        defineReadOnly(this, \"_wrappedEmits\", { });\n\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\n                uniqueNames[`%${ name }`].push(signature);\n            }\n\n            if ((<Contract>this)[signature] == null) {\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\n            }\n\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) { return; }\n\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n\n            const signature = signatures[0];\n\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if ((<Contract>this)[name] == null) {\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\n                }\n            } catch (e) { }\n\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\n        return getContractAddress(transaction);\n    }\n\n    static getInterface(contractInterface: ContractInterface): Interface {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n\n    // @TODO: Allow timeout?\n    deployed(): Promise<Contract> {\n        return this._deployed();\n    }\n\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\n        if (!this._deployedPromise) {\n\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n\n        return this._deployedPromise;\n    }\n\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\n        }\n\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\n\n        [\"from\", \"to\"].forEach(function(key) {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider: Signer | Provider | string): Contract {\n        if (typeof(signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n\n        return contract;\n    }\n\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName: string): Contract {\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\n    }\n\n    static isIndexed(value: any): value is Indexed {\n        return Indexed.isIndexed(value);\n    }\n\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n         }\n         return runningEvent\n    }\n\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\n        if (typeof(eventName) === \"string\") {\n\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName)\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof(topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) { }\n\n            // Filter by the unknown topichash\n            const filter: EventFilter = {\n                address: this.address,\n                topics: eventName.topics\n            }\n\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n\n    _checkRunningEvents(runningEvent: RunningEvent): void {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\n        const event = <Event>deepCopy(log);\n\n        event.removeListener = () => {\n            if (!listener) { return; }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\n\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n\n        return event;\n    }\n\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\n        }\n\n        runningEvent.addListener(listener, once);\n\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log: Log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n\n    queryFilter(event: EventFilter | string, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\n        } else {\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\n        }\n\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n\n    on(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n\n    once(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\n        if (!this.provider) { return false; }\n\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventFilter | string): number {\n        if (!this.provider) { return 0; }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n\n    listeners(eventName?: EventFilter | string): Array<Listener> {\n        if (!this.provider) { return []; }\n\n        if (eventName == null) {\n            const result: Array<Listener> = [ ];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener)\n                });\n            }\n            return result;\n        }\n\n        return this._getRunningEvent(eventName).listeners();\n    }\n\n    removeAllListeners(eventName?: EventFilter | string): this {\n        if (!this.provider) { return this; }\n\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n\n        return this;\n    }\n\n    off(eventName: EventFilter | string, listener: Listener): this {\n        if (!this.provider) { return this; }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\n        return this.off(eventName, listener);\n    }\n\n}\n\nexport class Contract extends BaseContract {\n    // The meta-class properties\n    readonly [ key: string ]: ContractFunction | any;\n}\n\nexport class ContractFactory {\n\n    readonly interface: Interface;\n    readonly bytecode: string;\n    readonly signer: Signer;\n\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\n\n        let bytecodeHex: string = null;\n\n        if (typeof(bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        } else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = (<any>bytecode).object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\n\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\n        let tx: TransactionRequest = { };\n\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n\n        return tx\n    }\n\n    async deploy(...args: Array<any>): Promise<Contract> {\n\n        let overrides: any = { };\n\n        // If 1 extra parameter was passed in, it contains overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            overrides = args.pop();\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Resolve ENS names and promises in the arguments\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n        params.push(overrides);\n\n        // Get the deployment transaction (with optional overrides)\n        const unsignedTx = this.getDeployTransaction(...params);\n\n        // Send the deployment transaction\n        const tx = await this.signer.sendTransaction(unsignedTx);\n\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\n        // Add the modified wait that wraps events\n        addContractWait(contract, tx);\n\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n    }\n\n    attach(address: string): Contract {\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\n    }\n\n    connect(signer: Signer) {\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\n    }\n\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n\n        if (typeof(compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n\n        const abi = compilerOutput.abi;\n\n        let bytecode: any = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, signer);\n    }\n\n    static getInterface(contractInterface: ContractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\n        return getContractAddress(tx);\n    }\n\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n"],
  "mappings": "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",
  "names": ["paramType", "init_lib", "runningEvent"]
}
